<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ActionScript 3.0 Language Specification</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
<h1>ActionScript 3.0 Language Specification</h1>

<p>This document defines the ActionScript 3.0 language, which is designed to be forward- compatible with the next edition of ECMAScript (ECMA-262).</p>
<p>This document is complete in the syntax and high-level semantics of the language, but lacks details regarding features that have not changed from the ECMA-262 edition 3 specification, compatibility with ActionScript 2.0, and low-level semantics of some new features.</p>



  <h1>1 Tutorial introduction</h1>
<p>An ActionScript program consists of zero or more package definitions followed by zero or more directives, which includes non-package definitions and statements. Statements inside and outside of package definitions are evaluated in order, independent of their nesting inside a package.</p>



  <h1>1.1 Hello world</h1>
<p>The following sections show various ways to implement simple programs such as the familiar 'hello, world' program in ActionScript 3.0:</p>
<div class="listing">
<pre>
trace("hello, world");
</pre>
</div>
<p>This is a single expression statement that calls a function named <code>trace()</code> with the argument that is a literal string <code>"hello, world"</code>. An expression statement does nothing but execute an expression.</p>
<h1>1.2 Expressions</h1>
<p>Here are some examples of expressions:</p>
<div class="listing">
<pre>
x = 1 + 2
x = y()
x = y..z
x = o.ns::id
</pre>
</div>
<p>Expressions evaluate to values: </p>
<ul>
<li>
<code>1+2</code> evaluates to <code>3</code>.</li>
  <li>
<code>y()</code> evaluates to the result of calling the function <code>y</code> with no arguments.</li>
  <li>
<code>y..z</code> evaluates to the set of all properties identified by <code>z</code> in the value of <code>y</code> and the descendants of <code>y</code>. The descendants accessor operator (..) is part of the ActionScript 3.0 implementation of ECMAScript for XML (E4X).</li>
  <li>
<code>o.ns::id</code> evaluates to the value of the property <code>ns::id</code> of the value of <code>o</code>, where <code>o</code> represents an object, <code>ns</code> represents a namespace, and <code>id</code> represents an identifier.</li>
</ul>
<h1>1.3 Statements</h1>
<p>Statements are executed in the order that they appear in a block. Some statements change control flow by abrupt completion, such as <code>break</code> and <code>continue</code>, or by iteration, such as <code>while</code> and <code>do</code>. An example of a statement follows:</p>
<div class="listing">
<pre>for (var i:int = 0; i &lt; 5; i++) {<br>    trace(i);<br>}</pre>
</div>


 <h1>1.4 Variables</h1>
<p>Variables define properties whose values can change at runtime. They can be defined with either the <code>var</code> keyword or the <code>const</code> keyword. A variable that is defined with the <code>var</code> keyword may be assigned by any code that can access it. A variable that is defined with the <code>const</code> keyword may only be set by its initializer, or its class's instance constructor if it is an instance variable. An example of variables follows:</p>
<div class="listing">
<pre>
var x = 10
const PI = 3.1415
</pre>
</div>


  <h1>1.5 Functions</h1>
<p>Functions define properties whose values can be called. An example of a function follows:</p>
<div class="listing">
<pre>
function hello() {
    trace("hello, world")
}
hello()
</pre>
</div>
<p>Depending on where a function is defined, it results in a property whose value is a function closure or a method. A function closure is a first class object that can be treated as a collection of properties or a callable object. A method is tightly bound to the object that it is associated with. The <code>this</code> reference of a function is bound to the base object of the call expression, or the global object if none is specified.</p>
<div class="listing">
<pre>
function hello() {
    trace("hello, world")
    trace(this) // this refers to global object
}
hello()
</pre>
</div>
<p>A method is a function that is tightly bound to an object. A method can be extracted from its instance, but, unlike function closures, the value of <code>this</code> always refers to the instance it is extracted from.</p>



  <h1>1.6 Classes</h1>
<p>A class is an object that can be used as a constructor of instances that share the same type and properties. An example of a class follows:</p>
<div class="listing">
<pre>
class Greeter {
    var saying = "hello, world"
    function hello() { 
        trace(saying)
    }
}
var greeter : Greeter = new Greeter
greeter.hello()
</pre>
</div>
<p>Class definitions are used to define the fixed properties of a class object. Property definitions that are marked with the <code>static</code> attribute become properties of the class object, and those that are not become properties of instances of the class.</p>
<p>Class and instance properties are either methods or slots. A method is defined by a function definition inside a class definition. A method has a definition (called a method trait) that is shared among all instances of the same type. Unlike an ordinary function object, a method is tightly bound to the object it is associated with. Whenever and however it gets invoked, the meaning of the expression <code>this</code> is always the same. In fact, methods can be extracted from their instance and treated as first class objects (called bound methods), much like function objects can be. There is one important difference between a function closure and a bound method. With a bound method, the <code>this</code> reference is bound into the object so that whenever it is invoked the original <code>this</code> reference is used. With a function closure, <code>this</code> is generic and refers to any object the function happens to be associated with when it is invoked.</p>
<p>Slots are defined by variable definitions inside a class definition. An instance variable has a definition (called a slot trait) that is shared among all instances of the same type, but a unique location in each object.</p>



  <h1>1.7 Interfaces</h1>
<p>An interface defines a contract between an instance and code that uses that instance. When a class implements an interface, it guarantees that it will provide the methods declared in that interface. An implementing method must be declared <code>public</code>, in which case it will implement all unimplemented interface methods with the same identifier. An example of an interface follows:</p>
<div class="listing">
<pre>
interface Greetings {
    function hello()
    function goodmorning()
}

class Greeter implements Greetings {
    public function hello() { 
        trace("hello, world")
    }
    public function goodmorning() { 
        trace("goodmorning, world")
    }
}
var greeter : Greetings = new Greeter()
greeter.hello()
</pre>
</div>


  <h1>1.8 Packages</h1>
<p>Packages in ActionScript are very similar to packages in Java and namespaces in C# and C++. Packages are useful for organizing frameworks (or toolkits, or APIs) into sets of related definitions: classes, namespaces, interfaces, functions, and variables. </p>
<p>Client code can import all or parts of a package to access the functionality it provides without cluttering its global namespace with unneeded names. In the following example, the <code>import</code> directive makes the class Greeter visible to the global code that contains the import directive.</p>
<div class="listing">
<pre>
package actors {
    public class Greeter {
        public function hello() { 
            trace("hello, world")
        }
    }
}
import actors.Greeter
var greeter : Greeter = new Greeter
greeter.hello()
</pre>
</div>


  <h1>1.9 Namespaces</h1>
<p>Namespaces are useful for controlling the visibility of a set of properties independent of the major structure of the program. Packages, classes and interfaces, along with their implicitly defined access control namespaces, allow authors to control the visibility of names in parallel with the organization of those packages, classes and interfaces. But it is sometimes necessary to control the names independent of the lexical structure of a program. Examples of this include the following:</p>
<ul>
<li>Making the public interface of a set of classes look different to different client modules</li>
  <li>Evolving a class over time without changing the behavior of existing programs</li>
  <li>Providing privileged access to a limited set of clients</li>
</ul>
<p>Use packages to give or gain access to a set of features. Use namespaces to give or gain access to a particular facet, version, or privilege independent of the structure of a program. An example that uses namespaces follows:</p>
<div class="listing">
<pre>
// ActionScript file: actors/English.as
package actors{
    public namespace English = "http://www.adobe.com/2007/Examples/English";
}

// ActionScript file: actors/French.as
package actors {
    public namespace French = "http://www.adobe.com/2007/Examples/French";
}

// ActionScript file: actors/BilingualGreeter.as
package actors {
    public class BilingualGreeter {
        English function hello():void { 
            trace("hello, world");
        }
        French function hello():void { 
            trace("bonjour, le monde");
        }
    }
}

// ActionScript file: Test.as
package {
    import flash.display.Sprite;
   
    public class Test extends Sprite
    {
        public function Test()
        {
        }
    }
}

import actors.*;
var greeter : BilingualGreeter = new BilingualGreeter();
use namespace English;    // Make all identifiers in the English namespace
                          // visible
greeter.hello();          // Invoke the English version
greeter.French::hello();  // Invoke the French version
</pre>
</div>


 <h1>2 Design perspective</h1>
<p>It is sometimes difficult to understand design decisions without understanding the perspective of the designers. Here are the major viewpoints that have grounded the design changes introduced in ActionScript 3.0 and ECMA-262 edition 4.</p>



  <h1>2.1 Compatibility with existing programs</h1>
<p>ECMAScript was originally designed for and used by consumers of host object models. Because ECMAScript is one of the most widely used programming languages, it is important that existing ECMAScript-compliant programs continue to work in systems that are updated to support the new definition of the language.</p>
<p>Therefore, programs written for ECMA-262 edition 3, compact profile, or ECMAScript for XML (ECMA-357 edition 2, also known as E4X) must continue to behave the same way in both ActionScript 3.0 and ECMA-262 edition 4.</p>



  <h1>2.2 Compatibility with existing object models</h1>
<p>Through 10 years of use, ECMAScript has come under great pressure to become a language for creating object models. This is a natural consequence of the need for application and tool developers to extend and override the functionality of the built-in objects provided by host environments. A few examples of this include HTML, Flash, Acrobat, and VoiceXML.</p>
<p>These embeddings contain host objects with behaviors that can only be approximated with the features of ECMA-262 edition 3, and as such are implemented in a way that is inefficient and fragile.</p>
<p>Therefore, one of the mandates of edition 4 is to make it possible to create object models, such as the ECMA-262 edition 3 built-ins, HTML DOM and ActionScript API, in a way that not only makes it natural to give these object models behavior like the existing object models, but that also makes them robust and efficient. </p>



  <h1>2.3 Controlling the visibility of names</h1>
<p>It is a well-known problem that naming conflicts arise when independently created libraries are used by a single application. It is also common that the meaning of a name must be different for different uses of a single component.</p>
<p>Therefore, edition 4 strives to minimize the occurrence of naming conflicts when independently created libraries are used by a single application and make it possible to resolve those conflicts when they do occur. Furthermore, edition 4 strives to make it possible for users to select the meaning of names between versions and uses.</p>



  <h1>2.4 Choosing between reliability and flexibility</h1>
<p>Whereas the original purpose of ECMAScript was to provide a scripting language for automating web pages and other hosted applications where lenient runtime behavior is preferred and scripts are small enough that performance is often not a concern, libraries written in ECMAScript can be very large and complex, and be constrained by aggressive performance requirements. These libraries are often created ahead of time using IDEs and stand-alone compilers. In this case, developers are willing to give up some flexibility to be guaranteed that certain kinds of errors will not occur at runtime, and that their code will run as efficiently as possible.</p>
<p>Also, it is desirable when targeting low-powered platforms to minimize the amount of processing that must occur to execute programs on the client.</p>
<p>Therefore, edition 4 allows developers to trade flexibility and compatibility for reliability and efficiency by choosing a well-defined subset of ECMAScript that can be compiled ahead-of-time for more aggressive compile-time semantic analysis and optimization.</p>



  <h1>3 Phases and dialects of interpretation</h1>
<p>There are three phases of execution: parsing, verification and evaluation. Invalid programs will terminate during one of these three phases, before the program runs to completion.</p>
<p>There are two dialects of the language described by this specification, one a subset of the other. These languages differ only in that one has additional verification rules. The more permissive language is called the standard dialect, and the more restrictive language is called the strict dialect.</p>



  <h1>3.1 Parsing</h1>
<p>The parsing phase translates the source code of a program into an internal format suitable for verification. The syntax rules of the language are described using grammar productions throughout this specification.</p>



  <h1>3.2 Verifying</h1>
<p>The verification phase ensures that the program obeys the static semantics of the language. In the standard dialect, verification may be done anytime before a construct is first evaluated. In the strict dialect, verification must happen before any part of the program is evaluated.</p>
<p>The differences in the verification rules of the standard dialect and the strict dialect mean that some programs that would verify in the standard language will not verify in the strict language. However, all programs that verify in the strict language will verify and run with the same behavior in the standard language.</p>



  <h1>3.2.1 Compile time constant expressions</h1>
<p>A compile time constant expression is an expression whose value can be determined at compile time (during verification), before any part of the program has been executed. Compile time constant expressions consist of the following sub-expressions:</p>
<ul>
<li>Literals such as null, Number, Boolean and String literals</li>
  <li>References to properties whose values are compile-time constants</li>
  <li>Operators whose results can be computed at compile time</li>
</ul>
<p>Expressions in certain contexts are required to be compile time constant expressions: </p>
<ul>
<li>Type annotations</li>
  <li>Inheritance clauses references</li>
  <li>Attributes</li>
  <li>Pragma arguments (for example, use namespace ns2)</li>
</ul>
<p>Of these, inheritance clause references and attributes must not have forward references.</p>



  <h1>3.3 Evaluating</h1>
<p>The evaluation phase takes the parsed, verified program and evaluates it to produce side effects in its host environment and a final value. The semantics of evaluation are the same for both dialects of the language.</p>



  <h1>3.4 Strict verification</h1>
<p>The goal of strict mode is reliability of new programs. The strict language is a subset of the standard language and has three kinds of constraints:</p>
<ul>
<li>Expressions have static types and type errors are verification errors</li>
  <li>Common programming errors are caught by additional verification rules</li>
  <li>Verification errors are reported ahead-of-time</li>
</ul>
<h1>3.4.1 Type errors</h1>
<p>Here is an example of a program that is valid in the standard dialect but not valid in the strict dialect:</p>
<div class="listing">
<pre>
class A {}
class B extends A {}
var a : A = new B
var b : B = a        // type error, static type of 'a' is A,
                     // which is incompatible with B
</pre>
</div>
<p>In the standard dialect this program has no error, since type errors are runtime errors and the runtime value of <code>a</code> is an instance of <code>B</code>, which is clearly a member of the type B.</p>



  <h1>3.4.2 Strict errors</h1>
<p>The strict dialect adds various semantic errors to catch common programming mistakes that are allowed in the standard dialect for the sake of compatibility and flexibility. </p>
<p>Verification errors of strict mode fall into these categories:</p>
<ul>
<li>Function call signature matching</li>
  <li>Duplicate definition conflicts</li>
  <li>Unbound references</li>
  <li>Dynamic addition of properties on sealed objects</li>
  <li>Writing to <code>const</code> variables</li>
  <li>Deleting fixed properties</li>
  <li>Comparison expressions with incompatible types</li>
  <li>Unfound packages</li>
</ul>
<h1>4 Definitions</h1>
<p>This section defines terms used elsewhere in this specification.</p>



  <h1>4.1 Bound method</h1>
<p>A bound method is a method that is extracted from the instance to which it is attached. This typically occurs when a method is passed as an argument to a function. Such a method is bound to the original instance in that the <code>this</code> reference continues to refer to that instance.</p>



  <h1>4.2 Class</h1>
<p>Every class definition is represented by a special class object that stores information about the class. Among the constituents of the class object are two traits objects and a prototype object. One traits object stores information about the static properties of the class. The other traits object stores information about the instance properties of the class and serves as the primary mechanism for class inheritance. The prototype object is a special object that can be used to share state among all instances of a class.</p>



  <h1>4.3 Class method</h1>
<p>A class method, also called a static method, is a method that is attached to an entire class, rather than to an instance of a class. Class methods, unlike instance methods, can only be accessed through the class, and cannot be accessed through a class instance.</p>



  <h1>4.4 Class variable</h1>
<p>A class variable, also called a static variable, is a variable that is attached to a class object rather than to an instance of the class. Class variables, unlike instance variables, can only be accessed through the class, and cannot be accessed through a class instance.</p>



  <h1>4.5 Delegate</h1>
<p>Delegates are objects that can substitute for other objects during property name lookup. Every object has a delegate, which is either of the same type as that object or of type Object. An instance of a class is an example of an object that has a delegate of the same type. Class instances all share the same delegate--the defining class's prototype object. A class's prototype object is a special instance of that class that provides a mechanism for sharing state across all instances of a class. </p>
<p>At runtime, when a property is not found on a class instance, the delegate, which is the class prototype object, is checked for that property. If the prototype object does not contain the property, the process continues with the prototype object's delegate. A prototype object is an example of an object that has a delegate of type Object. All class prototype objects share the same delegate--a special static property of the Object class named Object.prototype.</p>



  <h1>4.6 Final</h1>
<p>A class declared as final cannot be extended. A method declared as final cannot be overridden.</p>



  <h1>4.7 Function</h1>
<p>A function is a callable object. A function can be either a function closure or a method, depending on how the function is defined.</p>



  <h1>4.8 Function Closure</h1>
<p>A function closure is a function that is neither attached to another object nor defined as part of a class. Function closures are first-class objects that can be treated as a collection of properties or as callable objects. Contrast function closures with methods, which are functions that are attached to an object or an instance of a class.</p>



  <h1>4.9 Instance</h1>
<p>An instance is an object that is created using a class definition.</p>



  <h1>4.10 Instance method</h1>
<p>An instance method is a method defined without the <code>static</code> attribute. Instance methods attach to a class instance instead of to the class as a whole. </p>



  <h1>4.11 Instance variable</h1>
<p>An instance variable is a variable defined without the <code>static</code> attribute. Instance variables attach to a class instance instead of to the class as a whole.</p>



  <h1>4.12 Method</h1>
<p>A method is a function that is attached to an object or an instance of a class. Contrast with function closures, which are functions not attached to an object or an instance of a class.</p>



  <h1>4.13 Object</h1>
<p>Every value visible in a program is an object. An object is a collection of properties. </p>



  <h1>4.14 Property</h1>
<p>A property associates a name with a value or method. A method can be either a get or set accessor or an ordinary method. Fixed properties cannot be redefined or deleted. Dynamic properties are created at runtime and can be redefined and deleted. Internally, fixed properties are expressed as traits. Dynamic properties are expressed as a map between names and values.</p>



  <h1>4.15 Prototype</h1>
<p>A prototype object is a special class instance that is stored internally by a class object. It is an object that becomes the implicit delegate shared by all instances of a particular class or function. A class prototype is an instance of that class, while the prototype's delegate is an instance of Object.</p>



  <h1>4.16 Sealed</h1>
<p>An object is sealed if properties cannot be added to it at runtime. By default, class definitions create sealed class instances. To define a class that creates instances that are not sealed, use the <code>dynamic</code> attribute when declaring the class.</p>



  <h1>4.17 Slots</h1>
<p>A slot is a location inside an instance used to store the value of a variable property. A slot is allocated for each variable declaration.</p>



  <h1>4.18 Trait</h1>
<p>A trait is a fixed property shared by all instances of the same type. The collection of traits defines the invariants of the object's type. For this reason, use the traits object to describe the type of an object. Traits are declared in the definition of the class used to create an object.</p>
<div class="listing">
<pre>
class A 
{
    var x
    function m() { }
    function get y() { return 10 }
    function set y(v) { }
}
</pre>
</div>
<p>Each member of this class definition causes a trait to be added to the traits object for instances of A. When an instance is created by class A, the resulting object has the properties <code>x</code>, <code>m</code>, and <code>y</code>, implemented by traits for var <code>x</code>, function <code>m</code>, function <code>get y</code> and function <code>set y</code>. </p>
<p>Traits express the type of an instance. All traits are copied down to the derived traits objects. All traits must be implemented. Interface members are abstract and so their traits must be implemented in any class that inherits them.</p>



  <h1>5 Names</h1>
<p>A name consists of a string and a namespace. Names are introduced into a particular scope by a definition. Those definitions are referred to by names that result from expressions.</p>
<p>The qualified forms result in a single name consisting of the given qualifier and identifier. The unqualified forms result in a set of names consisting of strings qualified by the open namespaces.</p>
<p>The visibility of an identifier is controlled by the set of open namespaces. The set of open namespaces includes all of the implicitly opened namespaces and the namespaces opened by the user. The implicitly opened namespaces are as follows:</p>
<ul>
<li>Public namespace</li>
  <li>Internal namespace for the current package</li>
  <li>Private namespace for the current class</li>
  <li>Protected namespaces for the current class</li>
</ul>
<p>The namespaces opened by the user are controlled by the use namespace directives that are in scope. For example:</p>
<div class="listing">
<pre>
namespace mx = "http://macromedia.com/mx"
use namespace(mx)
o.m()
</pre>
</div>
<p>In this example, the reference to <code>o.m()</code> will involve the names qualified by the namespace <code>mx</code> as well as the implicitly opened namespaces: public, internal, etc.</p>
<p>The terms namespace and qualifier are used interchangeably when talking about qualified names.</p>



  <h1>5.1 Definition names</h1>
<p>A name introduced by a definition might get its qualifier from one of various sources:</p>
<ul>
<li>Top-level definitions in a package have the package name as their qualifier</li>
  <li>Top-level definitions outside of a package are placed into an anonymous namespace that is unique to the source code file that contains the definitions, which means that such definitions are visible only within that file.</li>
  <li>Interface members have the interface name as their qualifier</li>
  <li>Dynamic property names have the <code>public</code> namespace as their qualifier</li>
  <li>Definitions inside a class have the <code>internal</code> namespace of the current package as their qualifier, unless a namespace attribute is specified</li>
  <li>A definition with a namespace attribute has its corresponding namespace as its qualifier</li>
  <li>A definition with an access control attribute has the implicitly defined namespace for that access specifier as its qualifier</li>
</ul>
<p>It is an error to introduce a name with an identifier that has already been defined in an open namespace in the same scope, but with a different qualifier.</p>



  <h1>5.2 Reference names</h1>
<p>Reference names result from various forms of expressions. The two main distinctions in these forms are whether the name is qualified or unqualified, and whether the identifier is a literal identifier or an expression.</p>
<p>The following table shows the kinds of references that include qualified and unqualified, literal and expression names.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p></p>
    </td>
    <td>
      <p>Literal</p>
    </td>
    <td>
      <p>Expression</p>
    </td>
  </tr>
<tr>
<td>
      <p>Unqualified</p>
    </td>
    <td>
      <code>o.id, id</code>
    </td>
    <td>
      <code>o[expr]</code>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>Qualified</p>
    </td>
    <td>
      <code>o.q::id, q::id</code>
    </td>
    <td>
      <code>o.q::[expr], q::[expr]</code>
    </td>
  </tr>
</table>
<ul>
<li>A qualified or unqualified literal identifier is equivalent to the dynamic form with its expression operand replaced by a string literal representing the literal identifier</li>
  <li>An unqualified expression reference results in multiple names (called a multiname), one for every open namespace combined with the string value of the expression <code>expr</code>
</li>
  <li>A qualified expression reference results in a qualified name that consists of the value of the qualifier <code>q</code> combined with the string value of the expression <code>expr</code>
</li>
</ul>
<h1>5.3 Name lookup</h1>
<p>An expression involving a name results in an internal reference value used by certain operators to perform actions. To describe name lookup, we distinguish between two types of references: those that include a base object (object references), and those that do not (lexical references.) </p>
<p>Looking up a reference involves determining its ultimate qualified name (in the case of unqualified references) and its base object.</p>



  <h1>5.3.1 Object references</h1>
<p>Object references result from expressions involving the dot or bracket operators. They may be qualified or unqualified. The following table shows various forms of object references.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p></p>
    </td>
    <td>
      <p>Literal</p>
    </td>
    <td>
      <p>Expression</p>
    </td>
  </tr>
<tr>
<td>
      <p>Unqualified</p>
    </td>
    <td>
      <code>o.id</code>
    </td>
    <td>
      <code>o[expr]</code>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>Qualified</p>
    </td>
    <td>
      <code>o.q::id</code>
    </td>
    <td>
      <code>o.q::[expr]</code>
    </td>
  </tr>
</table>
<p>We use the expression form of references to describe the name lookup semantics. However, every literal name can be rewritten as an expression name through the following steps:</p>
<ul>
<li>If the expression is an unqualified literal name, then replace the dot operation <code>o.id</code> with a bracket operations of the form <code>o['id']</code>
</li>
  <li>Otherwise, the expression is a qualified literal name, so replace the operand of the dot operation with the dot operation <code>o.q::['id']</code>
</li>
</ul>
<h4>
<a name="wp126115"></a>5.3.1.1 Unqualified object references</h4>
<p>The unqualified expression <code>o[expr]</code> is a reference to a property of the value of the expression <code>o</code> that has a name that matches one of the names of the set of names (multiname) composed in the following way:</p>
<ul>
<li>Let <code>id</code> be the string value of the expression <code>expr</code>
</li>
  <li>Let <code>m</code> be an empty set of names</li>
  <li>For each namespace <code>q</code> in the set of open namespaces:    <ul>
<li>Let <code>n</code> be a name with the qualifier <code>q</code> and the identifier <code>id</code>
</li>
      <li>Add <code>n</code> to the set of names <code>m</code>
</li>
    </ul>
</li>
  <li>Return <code>m</code>
</li>
</ul>
<p>The single name of a multiname reference <code>r</code> is determined by the following steps:</p>
<ul>
<li>Let <code>t</code> be the least derived type of <code>x</code> that contains at least one of the names in the multiname set <code>m</code> of the reference <code>r</code>
</li>
  <li>Let <code>m'</code> be the intersection of the set of names <code>m</code> and the property names in <code>t</code>
</li>
  <li>Let <code>n</code> be the set of names in the most derived type of <code>x</code> and in <code>m'</code>
</li>
  <li>If <code>n</code> is empty, return the name in <code>m</code> that is qualified by the public namespace</li>
  <li>If <code>n</code> contains one name, then return that name</li>
  <li>Report an ambiguous reference error</li>
</ul>
<p>The base object of this reference is the value of the expression <code>o</code>.</p>
<h4>
<a name="wp126139"></a>Qualified object references</h4>
<div class="listing">
<pre>
o.q::[expr]
</pre>
</div>
<p>This is a reference to a property inside the value of o that matches a single name. Because the qualifier is explicit, the qualified name is straightforward to compute:</p>
<ul>
<li>Let <code>ns</code> be the value of the expression <code>q</code>
</li>
  <li>Let <code>id</code> be the string value of the expression <code>expr</code>
</li>
  <li>Return the qualified name consisting of the namespace <code>ns</code> and the identifier <code>id</code>
</li>
</ul>
<p>The base object of this reference is the value of the expression <code>o</code>.</p>



  <h1>5.3.2 Lexical references</h1>
<div class="listing">
<pre>
q::[expr]
q::id
id
</pre>
</div>
<p>Lexical references result from expressions involving a name but no base object. Whether a lexical reference is qualified or unqualified, with a literal identifier or expression, it results in a search of the scope chain of the lexical environment until either a match is found or the last scope is searched.</p>
<p>The scope chain might include the following kinds of scopes:</p>
<ul>
<li>Code inside a <code>with</code> statement will have a <code>with</code> frame as the inner most scope on the scope chain.</li>
  <li>Code inside a function definition will have an activation object on its scope chain.</li>
  <li>Code inside an instance method will have the instance <code>this</code> object on its scope chain.</li>
  <li>Code inside of a class definition, including in instance and static methods, will have the class objects of its base classes and the current class on the scope chain. The inner most class object corresponds to the most derived class, and the outermost class object corresponds to the Object class.</li>
  <li>Code everywhere has the global object as the outer most object on its scope chain.</li>
</ul>
<p>The base object of a lexical reference is computed through the following steps:</p>
<ul>
<li>Let <code>s</code> be the list of scopes enclosing the reference being evaluated.</li>
  <li>Let <code>n</code> be the qualified name or set of qualified names that result from the operation described in section <a href="as3_specification48.html#126115">5.3.1.1 Unqualified object references</a>.</li>
  <li>Search the scopes in <code>s</code> starting from the innermost scope and continuing outwards until a scope is found that contains a property that matches <code>n</code>, or all scopes have been searched.</li>
  <li>If a match is found, return the scope that contains the matching property.</li>
  <li>Report a property not found error.</li>
</ul>
<h1>6 Types</h1>
<p>A type is a set of values. Expressions have known values at runtime, and properties have known types at compile time (as well as at runtime.) The various types of ActionScript 3.0 can be related graphically as a type lattice where the edges of the lattice indicate subset relationships.</p>
<p>The following diagram shows the relationships between the main built-in types of the language:</p>
<p><br><img src="/web/20171028212944im_/http://bloople.net/as3ls/images/as3_specificationa.jpg" border="0" hspace="0" vspace="0"><br></p>
<p>There are three fundamental program visible types (Null, Object and void). What makes these types fundamental is that their union includes all possible values in the language. Null includes null, void includes undefined, and Object includes every other value. Null and void are different because they do not have object-like properties (such as toString, valueOf), and they both have values that represent a missing value.</p>
<p>The type Null includes one value - the value that results of the primary expression <code>null</code>. The value <code>null</code> is used to represent the idea "no value" in the context of an Object typed reference. </p>
<p>The type void includes one value - the value that is the initial value of the global property <code>undefined</code> and the result of the unary expression <code>void 0</code>. The value <code>undefined</code> is used to represent the idea "no property" or "no value" in the context of an untyped reference.</p>
<p>While the need for two types that represent the idea of "no value" seems strange to programmers familiar with statically typed object-oriented languages, the distinction is useful in ActionScript 3.0 to represent the absence of a property or the absence of a value of an untyped property versus the absence of a typed property.  Here is an example:</p>
<div class="listing">
<pre>
dynamic class A {
var x : String
var y
}
var a : A = new A
print(a.x)    // null
print(a.y)    // undefined
print(a.z)    // undefined
a.y = 10
a.z = 20
print(a.y)    // 10
print(a.z)    // 20
</pre>
</div>
<p>When dealing with dynamic instances, there is little difference between a property that doesn't exist and a property with no type and no value. But there is a difference between a property that has a type and one that doesn't. This is one of the reasons for the existence of both types Null and void.</p>
<table border="0" cellpadding="0" cellspacing="0" class="notesidebar"><tr>
<td width="5">
<p><strong>NOTE</strong></p>    </td>
    <td width="1">
      <p> </p>
    </td>
    <td>
      <p>In ECMA-262 edition 3, program visible values were instances of one of six unrelated types (Undefined, Null, Boolean, Number, String and Object). Conversions were provided to translate a value from one type to another. ActionScript 3.0  provides the same conversions between the primitive types (void/Undefined, Null, Boolean, String, Number, int and uint).</p>
    </td>
  </tr></table>
<h1>6.1 Type operators</h1>
<p>The language includes two type operators that enable programs to test and manipulate values in terms of a type. These type operators are <code>is</code> and <code>as</code>. </p>



  <h1>6.1.1 Operator is</h1>
<p>The <code>is</code> operator appears in expressions of the form:</p>
<div class="listing">
<pre>
v is T
</pre>
</div>
<p>The <code>is</code> operator checks to see if the value on the left is a member of the type on the right. For user-defined types and most built-in types, <code>is</code> returns <code>true</code> if the value is an instance of a class that is or derives from the type on the right, otherwise it returns <code>false</code>. For built-in numeric types the result cannot be determined by the class of the value. The implementation must check the actual value to see if it is included in the value set of the type.</p>
<p>The following table shows the results of using various values and types with the <code>is</code> operator:</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr>
<th>
      <p>Value </p>
    </th>
    <th>
      <p>String</p>
    </th>
    <th>
      <p>Number</p>
    </th>
    <th>
      <p>int</p>
    </th>
    <th>
      <p>uint</p>
    </th>
    <th>
      <p>Boolean</p>
    </th>
    <th>
      <p>Object</p>
    </th>
  </tr>
<tr>
<td>
      <p>{}</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>"string"</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr>
<td>
      <p>"10"</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>null</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
  </tr>
<tr>
<td>
      <p>undefined</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr>
<td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>0</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr>
<td>
      <p>1</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>-1</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr>
<td>
      <p>1.23</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>-1.23</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr>
<td>
      <p>NaN</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
</table>
<h1>6.1.2 Operator as</h1>
<p>The <code>as</code> operator appears in expressions of the form:</p>
<div class="listing">
<pre>
v as T
</pre>
</div>
<p>The purpose of the <code>as</code> operator is to guarantee that a value is of certain type, and, if not, indicate so by returning the value <code>null</code>. </p>
<p>It is common usage to assign the result of an <code>as</code> expression to a property with the same type in that expression. If the destination type does not include null, the assignment will convert <code>null</code> to the default value of that destination type (that is, false for <code>as</code> Boolean and 0 for <code>as</code> Number). This results in loss of information about whether the original value is included in that type. Programs that need to distinguish between when a value is the default value and an incompatible value must assign the result to a property of type Object, check for <code>null</code>, and then downcast to the ultimate destination type.</p>
<p>The steps used to evaluate the <code>as</code> operator are:</p>
<ul>
<li>Let v be the value of the left operand</li>
  <li>Let T be the value of the right operand</li>
  <li>If T is not of type Type    <ul>
<li>Throw a TypeError</li>
    </ul>
</li>
  <li>If v is of type T     <ul>
<li>Return the value v</li>
    </ul>
</li>
  <li>Else    <ul>
<li>Return the value <code>null</code>
</li>
    </ul>
</li>
</ul>
<h1>6.2 Type Conversions</h1>
<p>A type conversion is the translation of a value to a value that is a member of a specific destination type. When the original value is a member of the destination type, the value is unchanged. We call this an identity conversion.</p>
<p>Type conversions occur at runtime in various contexts:</p>
<ul>
<li>Assignment expressions, argument lists, and return statements</li>
  <li>The <code>as</code> operator</li>
  <li>Other operators</li>
</ul>
<p>The result of the conversion depends on the context of the expression that yields the value to be converted:</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <code>var x : T = v</code>
    </td>
    <td>
      <p>Implicit conversion to <code>T</code></p>
    </td>
  </tr>
<tr>
<td>
      <code>var y : T = v as T</code>
    </td>
    <td>
      <p><code>v</code> or <code>null</code></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <code>var z : T = v + 10</code>
    </td>
    <td>
      <p>Conversion according to the rules of the operator</p>
    </td>
  </tr>
</table>
<p>Implicit conversions occur when a value is assigned to a property, passed as an argument to a function, or returned from a function. </p>
<p>When the destination type is a user-defined type <code>T</code>, an implicit conversion will succeed if the value is an instance of a class that is <code>T</code> or is derived from <code>T</code>. If an implicit conversion does not succeed, then a type error is thrown.</p>
<p>When the destination type is a primitive type, the implicit conversion is described by the corresponding abstract procedure (such as <code>toString()</code> and <code>toNumber()</code>.) The following table shows some implicit conversion results:</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr>
<th>
      <p>Value</p>
    </th>
    <th>
      <p>String</p>
    </th>
    <th>
      <p>Number</p>
    </th>
    <th>
      <p>int</p>
    </th>
    <th>
      <p>uint</p>
    </th>
    <th>
      <p>Boolean</p>
    </th>
    <th>
      <p>Object</p>
    </th>
  </tr>
<tr>
<td>
      <p>{}</p>
    </td>
    <td>
      <p>"[object Object]"</p>
    </td>
    <td>
      <p>NaN</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>{}</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>"string"</p>
    </td>
    <td>
      <p>"string"</p>
    </td>
    <td>
      <p>NaN</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>"string"</p>
    </td>
  </tr>
<tr>
<td>
      <p>"10"</p>
    </td>
    <td>
      <p>"10"</p>
    </td>
    <td>
      <p>10</p>
    </td>
    <td>
      <p>10</p>
    </td>
    <td>
      <p>10</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>"10"</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>null</p>
    </td>
    <td>
      <p>Null</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>null</p>
    </td>
  </tr>
<tr>
<td>
      <p>undefined</p>
    </td>
    <td>
      <p>Null</p>
    </td>
    <td>
      <p>NaN</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>null</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>true</p>
    </td>
    <td>
      <p>"true"</p>
    </td>
    <td>
      <p>1</p>
    </td>
    <td>
      <p>1</p>
    </td>
    <td>
      <p>1</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>true</p>
    </td>
  </tr>
<tr>
<td>
      <p>false</p>
    </td>
    <td>
      <p>"false"</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>false</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>0</p>
    </td>
    <td>
      <p>"0"</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>0</p>
    </td>
  </tr>
<tr>
<td>
      <p>1</p>
    </td>
    <td>
      <p>"1"</p>
    </td>
    <td>
      <p>1</p>
    </td>
    <td>
      <p>1</p>
    </td>
    <td>
      <p>1</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>1</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>-1</p>
    </td>
    <td>
      <p>"-1"</p>
    </td>
    <td>
      <p>-1</p>
    </td>
    <td>
      <p>-1</p>
    </td>
    <td>
      <p>2E+32-1</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>-1</p>
    </td>
  </tr>
<tr>
<td>
      <p>1.23</p>
    </td>
    <td>
      <p>"1.23"</p>
    </td>
    <td>
      <p>1.23</p>
    </td>
    <td>
      <p>1</p>
    </td>
    <td>
      <p>1</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>1.23</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>-1.23</p>
    </td>
    <td>
      <p>"-1.23"</p>
    </td>
    <td>
      <p>-1.23</p>
    </td>
    <td>
      <p>-1</p>
    </td>
    <td>
      <p>2E+32-1</p>
    </td>
    <td>
      <p>true</p>
    </td>
    <td>
      <p>-1.23</p>
    </td>
  </tr>
<tr>
<td>
      <p>NaN</p>
    </td>
    <td>
      <p>"NaN"</p>
    </td>
    <td>
      <p>NaN</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>0</p>
    </td>
    <td>
      <p>false</p>
    </td>
    <td>
      <p>NaN</p>
    </td>
  </tr>
</table>
<p>User-defined types do not have built-in conversion operators, so implicit and explicit conversions behave the same at runtime. Specifically, if a value is not a member of the destination type, then no conversion exists, implicit or explicit, and a runtime exception will result from a cast expression and the default value of the destination type (which is <code>null</code>) will be the result of an <code>as</code> expression.</p>



  <h1>6.3 Type annotations</h1>
<p>A type annotation can be used when declaring a variable, a function parameter, or a function return type to guarantee that the associated value will be a member of a specific data type. A type annotation is a suffix that takes the form of a colon character (<code>:</code>) followed by a data type. Examples of type annotations follow:</p>
<div class="listing">
<pre>
var num:Number
function foo(str:String) : Boolean {}
</pre>
</div>
<p>In the standard dialect, type mismatches are not reported at compile time. Rather, a runtime type conversion is attempted and an error is reported if the type conversion fails. For example, the following example not only compiles in the standard dialect, but also does not cause a runtime error:</p>
<div class="listing">
<pre>
var num : Number = "1.23"
trace(num is Number) // output: true
</pre>
</div>
<p>In the strict dialect, type mismatches are reported as compile-time errors. Accordingly, the previous example does not compile in strict mode because the string value <code>"1.23"</code> is not a member of the Number data type. In other words, a variable <code>v</code> that uses the following syntax will not compile unless <code>v</code> is a member of data type <code>T</code>:</p>
<div class="listing">
<pre>
var v:T
</pre>
</div>


  <h1>6.4 Runtime versus compile time type</h1>
<p>We sometimes refer to a class or interface that helps to define the structure of a value as the value's type. What we really mean is that that value is a member of that class or interface type. This distinction is subtle but important. Since a value might belong to any number of unrelated types, to say that it is of a particular type is misleading.</p>
<p>In dynamically typed languages, expressions don't have types; they have values whose types may change each time the expression is evaluated. </p>
<p>Statically typed languages make the important simplification of associating a type with every expression, even if it is a very general one, when it is compiled. In this way, the suitability of an expression can be checked against its use before it is ever actually run. The cost of this added reliability is the loss of flexibility that comes from not having to think about the types of values.</p>
<div class="listing">
<pre>
function f( o : Object ) {
           var x : Number
           x = o           // Allowed in the standard dialect
       }
       f(10)                  // No problem, x gets set to 10
</pre>
</div>
<p>Other places where the differences between dynamic and static type checking can be seen are property access, and method invocation. </p>
<div class="listing">
<pre>
function f( o : Object ) {
           o.g()
           return o.x
       }
</pre>
</div>
<p>Whereas in a static type system, the binding for a method call or property read would need to be known at compile-time, the standard dialect always defers that checking until runtime.</p>
<p>The strict dialect has a hybrid type system. Normally, static type rules are used to check the compatibility of an expression with its destination type, but there are a few special cases. For example, when an expression on the right-hand side of an assignment expression consists of a reference to a property with no type, name lookup is deferred to runtime. When an object reference has a base object that is an instance of a dynamic class, the reference is checked at runtime. These dynamic typing features are useful when strict dialect programs are interoperating with dynamic features such as XML objects.</p>



  <h1>6.5 Untyped versus typed properties</h1>
<p>A property without a type annotation or with the wildcard annotation * (as in <code>var x : *</code>) is said to be untyped. Writing to an untyped property will always succeed since an untyped property can hold any value. Expressions that read from an untyped property are said to be untyped expressions. Assignment from an untyped expression may or may not succeed at runtime depending on whether its value can be implicitly converted to the destination type.  Nevertheless, in the strict dialect, assignments from untyped expressions are always type-checked at runtime, as in the standard dialect.</p>
<p>Use untyped properties when you want to store the result of an untyped expression or <code>undefined</code> as one of the values, or when you want to defer type checking to runtime.</p>



  <h1>6.6 Object types</h1>
<p>All program-visible types other than void and Null derive from type Object. This means that all values (except <code>undefined</code> and <code>null</code>) have properties that can be accessed by object references without the need to be wrapped in an object as they were in ECMA-262 edition 3.</p>



  <h1>6.7 Class types</h1>
<p>A class refers to a type or a value depending on its use.</p>
<div class="listing">
<pre>
class A 
{
    static var x
    var y
    prototype var z
}
var a : A  // A means type A
a = new A  // A means value A
</pre>
</div>
<br><img src="/web/20171028212944im_/http://bloople.net/as3ls/images/as3_specificationa3.jpg" border="0" hspace="0" vspace="0"><br><p>The value is a class object that has the form shown in the drawing above. The class object is CA. When used as a type, it evaluates to its instance traits (TA). When used in a <code>new</code> expression, the class serves as a factory object with a special method that creates a new instance (OA), which contains an internal delegate property pointing to the class object's prototype (P) and an internal traits property pointing to the class object's instance traits (TA).</p>



  <h1>6.8 Interface types</h1>
<p>An interface name can only be used where a type is expected:</p>
<div class="listing">
<pre>
interface I{}
var x : I        // I means type I
x = new I        // Error, I is not a value
</pre>
</div>


  <h1>6.9 Strict dialect and static types</h1>
<p>In the strict dialect, both expressions and properties have types. To be used to compute the value of a property, the expression must have a static type that is compatible with the type of the property. One way to think about static types of expressions and values is that the static type is a conservative approximation of the set of values that will result from that expression.</p>
<p>There are three special cases where static type rules are ignored, possibly allowing runtime errors to occur:</p>
<ul>
<li>Coercions from an untyped expression to any type</li>
  <li>Coercions from any type to type Boolean</li>
  <li>Coercions between different numeric types</li>
</ul>
<p>An explicit cast to a user-defined type is only useful in the strict dialect. This is because the effect of an explicit cast is to defer type checking until runtime, which is already the case in the standard dialect. This is not necessarily the case for built-in types that have special conversion behavior.</p>



  <h1>7 Variables</h1>
<p>A variable defines a slot with a name and a type. </p>
<p>A variable declared with the <code>const</code> rather than the <code>var</code> keyword, is read-only outside of the variable's intializer if it is not an instance variable and outside of the instance constructor if it is an instance variable. It is a verifier error to assign to a <code>const</code> variable outside of its writable region.</p>
<p>Variables exist in the following objects:</p>
<ul>
<li>Global object, inside and outside of a package</li>
  <li>Class objects</li>
  <li>Instance objects</li>
  <li>Activation objects</li>
</ul>
<h1>7.1 Variable modifiers</h1>
<p>When allowed by the context of the definition, the following attributes modify a variable definition. </p>
<ul>
<li>Access control namespaces</li>
  <li>User defined namespaces</li>
  <li><code>static</code></li>
  <li><code>prototype</code></li>
</ul>
<p>Access control and visibility control namespaces specify the namespace part of the variables name. </p>
<p>The static attribute may only be used inside a class definition and causes the variable to become a trait of the class object rather than the instance object. </p>
<p>The prototype attribute may only be used inside a class definition and causes the variable to be added to the class's prototype object and a get and set accessor to be added to the instance traits of the class. The purpose of the accessor methods is to simulate the behavior of accessing prototype properties in ECMA-262 edition 3.</p>



  <h1>7.2 Variable types</h1>
<p>All variables can have a type. A type annotation on a variable definition limits the set of values that can be stored in that variable. A type annotation must be a compile-time constant expression that evaluates to a class or interface value. The actual value used to represent the type of the variable is the instance traits of the referenced class or interface.</p>
<p>When a value is assigned to a variable, an implicit conversion to the variable's type is performed on the value. A type error occurs if there is no implicit conversion of that value to the variable's type. In the strict dialect, such errors are verification errors; in the standard dialect, type errors are runtime errors.</p>
<p>If no type is specified, or if the wildcard annotation * is specified (as in <code>var x : *</code>), the variable is said to be untyped. </p>



  <h1>8 Functions</h1>
<p>A function is a callable object. In general, functions consist of a block of code, a set of traits, and a list of scopes. Instance methods are functions that also consist of a receiver object to which <code>this</code> references are bound.</p>



  <h1>8.1 Function modifiers</h1>
<p>When allowed by the context of the definition, the following attributes modify a function definition: </p>
<ul>
<li>Access control namespaces</li>
  <li>User defined namespaces</li>
  <li>
<code>static</code> </li>
  <li>
<code>final</code> </li>
  <li>
<code>override</code> </li>
  <li>
<code>native</code> </li>
</ul>
<p>Access control and visibility control namespaces specify the namespace part of the function name. </p>
<p>The <code>static</code> attribute may only be used inside a class definition and causes the function to become a trait of the class object rather than the instance object. </p>
<p>The <code>final</code> attribute may only be used on a non-static function definition inside a class. A function modified by <code>final</code> cannot be overridden.</p>
<p>The <code>override</code> attribute may only be used on a non-static function definition inside a class. A function modified by <code>override</code> will override a method with the same name and signature as a non-final method of a base class.</p>
<p>The <code>native</code> attribute may be used to indicate that  the function is implemented in an implementation-defined way. The compiler should generate native stubs for functions that have this attribute.</p>



 <h1>8.2 Function signatures</h1>
<p>A function signature includes the number and types of its parameters and its result type. Like variable type annotations, the types of a function signature affect the implicit conversion of argument and return values when calling to and returning from a function. Function signatures are also used to match inherited methods to methods in a derived class.</p>



  <h1>8.3 Function objects</h1>
<p>Global and nested functions can be used as constructors in instantiation expressions, as shown in the following example:</p>
<div class="listing">
<pre>
function A() { this.x = 10 }
var o = new A
trace(o.x)     // traces 10
</pre>
</div>
<p>Function objects have a property named <code>prototype</code> whose value is used to initialize the intrinsic delegate property of the objects it creates. The <code>prototype</code> property has a default value of a new instance of the class Object. Building on the previous example:</p>
<div class="listing">
<pre>
function A() { this.x = 10 }
function B() {}
B.prototype = new A
var o = new B
trace(o.x)     // traces 10
</pre>
</div>
<p>The value of <code>o</code> is an instance of <code>B,</code> which delegates to an instance of <code>A</code>, which has a property named <code>x</code> with value of 10.</p>
<p>Constructor methods inside of a class are also used to create objects. But, unlike constructor functions, constructor methods create objects with a set of fixed properties (traits) associated with its class and a delegate that is also an instance of its class.</p>
<div class="listing">
<pre>
class A {
    var x
    function A() { this.x = 10 }
}
var o = new A
trace(o.x)     // traces 10
</pre>
</div>
<p>There are some subtle differences between the preceding example and the one involving a function constructor:</p>
<ul>
<li>
<code>x</code> is a fixed property of each instance of <code>A</code> rather than a dynamic property.</li>
  <li>
<code>A.prototype</code> is an instance of <code>A</code> rather than an instance of Object.</li>
  <li>The expression <code>A(expr)</code> does not call the function <code>A</code> defined in class <code>A</code>. It results in an explicit conversion of the value of <code>expr</code> to the type <code>A</code>.</li>
</ul>
<p>Class methods are functions that are defined with the <code>static</code> attribute inside of a class definition. A class method cannot be used as a constructor and does not define the <code>this</code> reference. Class methods are in the scope of the class object in which they are defined.</p>
<p>Instance methods are functions that are defined without the <code>static</code> attribute and inside a class definition. Instance methods are associated with an instance of the class in which they are defined. Instance methods can override or implement inherited class or interface methods and always have a value bound to <code>this</code>.</p>
<p>The value of <code>this</code> in an instance method is the value of the instance the method belongs to. When an instance method is extracted from an object, a bound method is created to bind the value of <code>this</code> to that host object. Assignment of the bound method to a property of another object does not affect the binding of <code>this</code>. For example:</p>
<div class="listing">
<pre>
class A {
    var x
    function A() { this.x = 10 }
    function m() { trace(this.x) }
}
var a = new A()
var o = { x : 20 }
o.m = a.m
o.m()   // traces 10
</pre>
</div>


  <h1>9 Classes</h1>
<p>A class is a type, a constructor of objects of that type, and a singleton object for sharing state and behavior. It is used as a constructor to create like instances. It is used as a type to constrain the value of properties. It is used as a singleton object to contain shared properties.</p>
<p>Classes are introduced with class definitions. A class definition can directly extend one other class definition and implement multiple interface definitions. The language does not support the concept of abstract classes and so a class must implement every interface method it inherits. </p>



  <h1>9.1 Class modifiers</h1>
<p>Class definitions may be modified by these attributes</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>dynamic</p>
    </td>
    <td>
      <p>Allow properties to be added to instances at runtime</p>
    </td>
  </tr>
<tr>
<td>
      <p>final</p>
    </td>
    <td>
      <p>Must not be extended by another class</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>internal</p>
    </td>
    <td>
      <p>Visible to references inside the current package (default)</p>
    </td>
  </tr>
<tr>
<td>
      <p>public</p>
    </td>
    <td>
      <p>Visible to references everywhere</p>
    </td>
  </tr>
</table>
<p>The default modifiers for a class definition are internal, non-dynamic, and non-final. </p>



  <h1>9.2 Class objects</h1>
<p>Class objects have the basic structure shown in the following illustration: </p>
<p><br><img src="/web/20171028212944im_/http://bloople.net/as3ls/images/as3_specificationa4.jpg" border="0" hspace="0" vspace="0"><br></p>
<p>The illustration shows the shape of the class object that results from the following simple class definition:</p>
<div class="listing">
<pre>
class A {}
</pre>
</div>


  <h1>9.2.1 Prototypes</h1>
<p>Every object has a prototype object that is used to match references at runtime. This prototype is called the delegate of the object. Delegation is a simple way to add shared properties to a group of related objects at runtime. </p>
<p>Prototype objects are always instances of the dynamic class Object and therefore can always be extended by the addition of dynamic properties. Unlike with function closures that have a prototype property that is a variable and can be reset to another object, classes have a prototype that is read-only and so always point to the same object. </p>



  <h1>9.2.2 Traits</h1>
<p>Properties of a class definition are represented as traits of the class object and its instances. Think of a trait as a fixed property that is shared by all instances of a type. Class objects (CA) are special in that they are a single instance with an internal type with a corresponding set of traits (TCA). The internal type of a class object describes the static properties of the class definition. The instance traits (TA) are shared by all instances created by the class object. They correspond to the instance properties of the class definition.</p>
<div class="listing">
<pre>
class A 
{
    static var x
    var y
}
</pre>
</div>
<p>In this example, the definition for <code>x</code> contributes a trait to the class traits (TCA), and the definition of <code>y</code> contributes a trait to the instance traits (TA).</p>



  <h1>9.2.3 Methods</h1>
<p>Each function definition inside a class definition results in a method inside the resulting class object or its instances. Two special methods are implicitly defined for each class: a class initializer; and an instance initializer. Code outside a function definition gets placed in the class initializer, which is called when the class object is created. Instance variable initializers are placed in the instance initializer method, which is called when an instance of the class is created and before the user-defined constructor is executed.</p>



  <h1>9.2.4 Slots</h1>
<p>Traits introduced by variable definitions describe a property that holds a value unique to each instance. Therefore, each object has a fixed array of slots that store those values, one for each variable trait. This is true of class objects as well as instance objects.</p>



  <h1>9.2.5 Instances</h1>
<p>All instances (OA) created by a class object (CA) will be given a traits (TA) and delegate (PA) object, as represented in this drawing</p>
<p><br><img src="/web/20171028212944im_/http://bloople.net/as3ls/images/as3_specificationa2.jpg" border="0" hspace="0" vspace="0"><br></p>



  <h1>9.2.6 Inheritance</h1>
<p>Each class inherits the instance traits of its base class. These traits are effectively copied down to the instance traits of the derived class. Classes that don't declare an explicit base class inherit the built-in Object class.</p>
<p>A class may also inherit the instance traits of one or more interfaces. Interface traits are abstract and so must be implemented by any class that inherits them.</p>
<p>Unlike static properties in other object-oriented languages, such as Java, static properties in ActionScript are not inherited, but they are in scope in the static and instance methods of the derived class.</p>



  <h1>9.2.7 Scopes</h1>
<p>Static properties are in scope of bodies of static and instance methods of the same class. Instance properties are in scope of the bodies of the instance methods. Instance properties shadow static properties with the same name. Static properties of base classes are in scope of static and instance methods of a class.</p>
<div class="listing">
<pre>
class A 
{ 
    static var ax
}
class B extends A 
{ 
    static var bx 
}
class C extends B 
{
    static var cx  
    var ix  
    function m() 
    {
        var mx
        gx = 10
        ax = 20
        bx = 30
        cx = 40
        mx = 50
    }
}
var gx
o = new C
o.m()
</pre>
</div>
<p>Scopes:</p>
    <p>{ mx } - activation scope</p>    <p>{ ix } - instance scope</p>    <p>{ cx } - static scope C</p>    <p>{ bx } - static scope B</p>    <p>{ ax } - static scope A</p>    <p>{ gx } - global scope</p>


  <h1>9.3 Class property attributes</h1>
<p>Class properties may be modified by the following attributes</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>static</p>
    </td>
    <td>
      <p>Defines a property of the class object</p>
    </td>
  </tr>
<tr>
<td>
      <p>private</p>
    </td>
    <td>
      <p>Visible to references inside the current class</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>internal (default)</p>
    </td>
    <td>
      <p>Visible to references inside the current package</p>
    </td>
  </tr>
<tr>
<td>
      <p>protected</p>
    </td>
    <td>
      <p>Visible to references inside instances of the current class and derived classes</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>public</p>
    </td>
    <td>
      <p>Visible to references everywhere</p>
    </td>
  </tr>
<tr>
<td>
      <p>AttributeExpression</p>
    </td>
    <td>
      <p>Namespace value is the qualifier for the name of the definition</p>
    </td>
  </tr>
</table>
<p>It is a syntax error to use any other attribute on a class property, unless otherwise specified in the section describing the specific type of property.</p>



  <h1>9.3.1 Static attribute</h1>
<p>The <code>static</code> attribute means the current definition defines a property of the class object.</p>



  <h1>9.3.2 Prototype attribute</h1>
<p>The <code>prototype</code> attribute was not implemented in ActionScript 3.0.</p>
<div class="listing">
</div>


  <h1>9.3.3 Access control namespace attributes</h1>
<p>Each access control attribute (<code>private</code>, <code>internal</code>, <code>protected</code>, and <code>public</code>) refers to a namespace value with a unique, private namespace name. Access control is provided by the fact that code outside of the attribute's access domain has no way to refer to that namespace value.</p>



  <h1>9.3.4 User-defined namespace attributes</h1>
<p>The value of an attribute expression that evaluates to a compile-time constant namespace is used as the qualifier of the definition's name.</p>
<div class="listing">
<pre>
namespace ns
class A 
{
    ns var x
}
</pre>
</div>
<p>In the preceding example, the name of the definition of <code>x</code> is qualified by the namespace <code>ns</code>. Note the following rules:</p>
<ul>
<li>Only one namespace attribute may be used per definition.</li>
  <li>Namespace attributes may not be used with an access control attribute.</li>
</ul>
<h1>9.4 Class body</h1>
<p>A class body may contain variable definitions, namespace definitions, function definitions, and statements:</p>
<div class="listing">
<pre>
class A
{
    static var x
    static function f() {}
    var y
    function g() {}
    trace("class loaded")
}
</pre>
</div>
<ul>
<li>Definitions result in class or instance traits depending on whether the static attribute occurs in their definition.</li>
  <li>Statements and initializers of static variables are added to the static initializer method of the class. The static initializer is called once, when the class is defined at runtime. The static initializer can be used to initialize variables of the class object and to invoke methods that are external to the current class.</li>
  <li>Initializers of instance variables are added to the instance initializer method.</li>
  <li>The scope chain of methods contained by the class body includes the class object, the base class objects (from most derived the least derived), and the global object.</li>
</ul>
<p>Note that it is not an error to define a class and instance property with the same name, as in the following example: </p>
<div class="listing">
<pre>
class A {
    static var x
    var x
}
</pre>
</div>
<p>It is also not an error to define a class property with the same name as a visible class property in a base class:</p>
<div class="listing">
<pre>
class A {
    static var x
}
class B extends A {
    static var x
}
</pre>
</div>


  <h1>9.5 Class variables</h1>
<p>Class variables are defined using the <code>var</code> or <code>const</code> keywords.</p>
<div class="listing">
<pre>
class A
{
    var x
    const k = 10
}
</pre>
</div>
<p>The meaning of <code>var</code> and <code>const</code> follow from the general meaning described in the sections <a href="as3_specification62.html#126778">7 Variables</a> and <a href="as3_specification6.html#125717">1.4 Variables</a>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>var</p>
    </td>
    <td>
      <p>May be written to multiple times</p>
    </td>
  </tr>
<tr>
<td>
      <p>const</p>
    </td>
    <td>
      <p>May be written to only once</p>
    </td>
  </tr>
</table>
<p><code>const</code> variable properties can be written to only once. The compiler uses a specific data flow analysis to determine if a <code>const</code> variable has been written to at the point of an assignment to that variable. Informally, the effect of this algorithm can be seen in the following error cases:</p>
<ul>
<li>It is an error to assign to a <code>const</code> instance or static variable in a statement that is outside of the instance or static initializer, respectively.</li>
  <li>It is an error to assign to a <code>const</code> variable more than once in a sequence of statements with no control flow branches.</li>
  <li>It is an error to assign to a <code>const</code> variable in more than one parallel control flow branch if the branch conditions are not compile-time constant expressions, or if the value of those branch conditions allow for one or more of those branches to be executed more than once.</li>
</ul>
<p>The default value of a class or instance variable is the value of undefined coerced to the type of the variable.</p>



  <h1>9.5.1 Static variables</h1>
<p>Variables declared with the <code>static</code> attribute add a slot trait to the class traits and a slot to the class object. Because there is only one class object per class, there is also only one slot per static variable. Static variables, like static methods, are not inherited, but are accessible from within the body of the class definition and through an explicit reference to the defining class's name. Static variables are in scope for all static and instance methods of the defining class and classes that inherit the defining class.</p>
<p>Static <code>const</code> variables must either have an initializer or be definitely unassigned before being set in the static initializer method.</p>
<p></p>
<table border="0" cellpadding="0" cellspacing="0" class="notesidebar"><tr>
<td width="5">
<p><strong>NOTE</strong></p>    </td>
    <td width="1">
      <p> </p>
    </td>
    <td>
      <p>Unlike in Java and C#, static variables are not inherited by derived classes and so cannot be referenced through derived class objects.</p>
    </td>
  </tr></table>
<h1>9.5.2 Instance variables</h1>
<p>Variables declared without the <code>static</code> attribute add a slot trait to the instance traits of the class and a slot to each instance of the class. Instance variables are always final and must not be overridden or hidden by a derived class. </p>
<p>As with all class properties, the default qualifier for the variable is the internal namespace. Other qualifiers can be specified by other namespace attributes. Both instance and class variables are implicitly final. Any attempt to hide or override one in a derived class will result in a verification error.</p>



  <h1>9.6 Class methods</h1>
<p>A method is a function associated with a specific object. Unlike a function closure, a method is not a value and cannot be used apart from the instance to which it is bound. The value of <code>this</code> inside a method is always the base object used to refer to the method, and always has the type of the class that implements the method, or subclasses of that class. </p>



  <h1>9.6.1 Constructor methods</h1>
<p>A function declared with the same identifier as the class it is defined in adds a constructor method to the class object. The constructor is called when a new instance of that class is created. A constructor may refer to the instance variables of the class that defines it. </p>
<div class="listing">
<pre>
class A 
{
    function A() {}
}
</pre>
</div>
<p>A constructor is public by default and may be defined with the public namespace or with no namespace attribute. If no constructor is defined by a class definition, a default constructor is defined implicitly. No more than one constructor can be defined for a class.</p>
<p>If the body of a constructor contains a SuperStatement, that statement must occur before the first reference to <code>this</code> or <code>super</code>, and before any <code>return</code> or <code>throw</code> statement. If a call to the <code>super</code> constructor is not explicit, one will be inserted before the first statement in the constructor body. Note the following errors:</p>
<ul>
<li>It is a syntax error to call the super constructor more than once.</li>
  <li>It is a syntax error to specify a <code>return</code> statement with an expression.</li>
  <li>It is a syntax error to specify a result type of a constructor.</li>
</ul>
<table border="0" cellpadding="0" cellspacing="0" class="notesidebar"><tr>
<td width="5">
<p><strong>NOTE</strong></p>    </td>
    <td width="1">
      <p> </p>
    </td>
    <td>
      <p>That there is no way to directly call the constructor of an indirect base class is intentional because it might lead to brittle or insecure programs.</p>
    </td>
  </tr></table>
<h1>9.6.2 Static methods</h1>
<p>Functions declared with the <code>static</code> attribute add a method trait to the class object traits. Static variables are in scope of a static method. </p>
<p>It is an error for the <code>this</code> or <code>super</code> expression to appear in the body of a static method.</p>
<table border="0" cellpadding="0" cellspacing="0" class="notesidebar"><tr>
<td width="5">
<p><strong>NOTE</strong></p>    </td>
    <td width="1">
      <p> </p>
    </td>
    <td>
      <p>Unlike in Java and C#, static variables are not inherited by derived classes and so cannot be referenced through derived class objects.</p>
    </td>
  </tr></table>
<h1>9.6.3 Instance methods</h1>
<p>Functions declared without the <code>static</code> attribute add a method trait to the instance traits of a class object. Static and instance variables are in scope of an instance method. The value of <code>this</code> inside an instance method is the instance the method is bound to.</p>
<div class="listing">
<pre>
class A 
{
    function m() { return this }
}
var a = new A
trace(a==a.m())   // trace true, this is the object 'm' is called on
</pre>
</div>
<p>In addition to the attributes defined for all class properties, the following attributes may be used on instance methods</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>final</p>
    </td>
    <td>
      <p>May not be overridden</p>
    </td>
  </tr>
<tr>
<td>
      <p>override</p>
    </td>
    <td>
      <p>Must override an inherited method</p>
    </td>
  </tr>
</table>
<p>The <code>override</code> attribute helps to avoid unintentional overriding of base class methods. It is a verifier error to use the <code>override</code> attribute on a function definition that does not override an inherited method. It is a verifier error to override an inherited method that is declared final. It is an error to define a method without the override attribute if the name matches the name of an inherited method.</p>
<p>The <code>prototype</code> attribute allows the addition of a fixed property to the prototype object, but not to the instance. Instance methods defined with the prototype attribute have function values that are compatible with ECMA-262 edition 3 prototype functions.</p>
<div class="listing">
<pre>
class A 
{
    prototype var f = function() { return this }
}
var a = new A
dynamic class B {}
var b = new B
b.f = a.f
b.f()   // traces "[object B]"
</pre>
</div>
<p>The instance of <code>B</code> becomes the value of <code>this</code>.</p>



  <h1>9.6.4 Accessor methods</h1>
<p>A method defined with the <code>get</code> or <code>set</code> keyword adds a get or set method trait to the instance or static traits of the defining class object. Accessor methods are called when the name of the accessor is used in a reference that reads or writes the value of that name.</p>
<div class="listing">
<pre>
class A 
{
    private var _x
    function get x() { return _x }
    function set x(v) { _x = v }
}
var a  = new A
a.x = 10       // calls set accessor of A
trace(a.x)     // traces 10, calls get accessor of A
</pre>
</div>
<p>Accessor methods are very similar in definition to regular methods. The differences are expressed by the following error conditions:</p>
<ul>
<li>Get methods must specify no parameters.</li>
  <li>Set methods must specify just one parameter.</li>
  <li>Get methods must return a value.</li>
  <li>Set methods have a result type <code>void</code> by default.</li>
  <li>Set methods must not specify a result type other than <code>void</code>.</li>
  <li>Get methods must not specify the result type <code>void</code>.</li>
  <li>If both a get and set method is defined with the same name, the parameter type of the set method and the result type of the get method must match.</li>
</ul>
<table border="0" cellpadding="0" cellspacing="0" class="notesidebar"><tr>
<td width="5">
<p><strong>NOTE</strong></p>    </td>
    <td width="1">
      <p> </p>
    </td>
    <td>
      <p>Accessors may only be defined at the top level of a class. They must not be nested inside another method or defined outside of a class.</p>
    </td>
  </tr></table>
<h1>9.6.5 Inheriting instance methods</h1>
<p>Instance methods are inherited by copying their instance traits down to the instance traits of the derived class. </p>
<h4>
<a name="wp127444"></a>9.6.5.1 Overriding instance methods</h4>
<p>Methods inherited from a class may be overridden in the derived class if the overriding method is given the override attribute and if its name, number and type of parameters, and return type match exactly. It is an error to attempt to override a method with a method that has the same name, but does not have the same number of parameters or parameters of different types or different return type.</p>
<h4>
<a name="wp127448"></a>9.6.5.2 Implementing interface methods</h4>
<p>Methods inherited from an interface must be implemented by a method with a name and signature that matches the inherited method. Interface methods are implemented by an instance method declared with the public attribute.  </p>
<p>A method that has the public attribute implements all inherited interface methods with a matching identifier.</p>
<div class="listing">
<pre>
interface I 
{
    function m()
}
interface J 
{
    function m()
}
class A implements I,J
{
    public function m() { trace("A.m") }
}
</pre>
</div>
<p>In this example, the definition of <code>m</code> in class <code>A</code> satisfies both interfaces <code>I</code> and <code>J</code>.</p>



  <h1>9.6.6 Bound methods</h1>
<p>Although a method is not a value by itself, it can be converted to a first class value called a bound method, through extraction. A bound method maintains the binding between a method and its instance.  The user-visible type of a bound method is Function.</p>
<div class="listing">
<pre>
class A 
{
    function m() { return this }
}
var a  = new A
var mc : Function = a.m     // create a bound method from m and a
trace(a==mc())   // trace true, mc remembers its this
</pre>
</div>


  <h1>10 Interfaces</h1>
<p>Interfaces provide a way for programs to express contracts between the producers and consumers of objects. These contracts are type safe, easy to understand, and efficient to implement. Programs should not have to pay a significant performance penalty for using interfaces.</p>
<p>An interface is a type whose methods must be defined by every class that claims to implement it. Multiple interfaces can be inherited by another interface through the <code>extends</code> clause or by a class through the <code>implements</code> clause. Instances of a class that implements an interface belong to the type represented by the interface. Interface definitions must only contain function definitions, which may include get and set methods.</p>
<p>Interface methods are not public by default, but are added to the public namespace by the implementing method definition.</p>



  <h1>10.1 Interface types</h1>
<p>An interface definition introduces a type into the current scope. The interface type is described by a set of abstract method traits and a list of interfaces that it extends. This set of abstract traits must be fully implemented by any class that inherits the interface. </p>
<p>An interface name refers to the interface type when it is used in a type annotation or an inheritance clause of a class or interface definition.</p>
<div class="listing">
<pre>
interface I {}
class A implements I {}    // I refers to type I
var x : I  = new A         // In each of these uses too
trace( x is I )
var y : I = x as I
</pre>
</div>
<p>When a reference is bound to an interface at compile-time, the value of that reference is always the compile-time interface value, even if the interface definition would be shadowed by another property at runtime. This is shown in the following example:</p>
<div class="listing">
<pre>
interface T {}
class A implements T {}
class B {}
function f() {
    var T = B
    var x = new A
    trace(x is T)  // T refers to interface T, not var T, traces true 
}
</pre>
</div>
<p>In this example, <code>T</code> in the <code>is</code> expression refers to the outer interface <code>T</code>, not the inner var <code>T</code>.</p>



  <h1>10.2 Interface methods</h1>
<p>Classes that implement an interface method must use the <code>public</code> attribute to implement all interface methods that have the same identifier name. The following example shows a class that implements two inherited interfaces with public qualified methods.</p>
<div class="listing">
<pre>
interface I 
{
    function f()
}
interface J
{
    function g()
}

class A implements I 
{
    public function f() {}
    public function g() {}
}
</pre>
</div>


  <h1>10.2.1 Visibility of interface methods</h1>
<p>Interface methods are visible when referenced through a property of the corresponding interface type or through a reference to the implementing class or subclass.</p>
<div class="listing">
<pre>
var a : A = new A
a.f()     // okay, f is visible through an A as {public}::f
a.g()     // okay, g is visible through an A as {public}::g
var i : I = b
i.f()     // okay, f is still visible through an I as {I}::f
i.g()     // error, g is not visible through an I as {I}::g
</pre>
</div>
<p>References through an object with an interface type are multinames that contain only the names qualified by the interface namespace and its super interface namespaces. This means that the names in the open namespaces (including public) will not be visible through a reference with an interface-typed base object. The motivation for this behavior is to express the idea of the interface as a contract between the producer and consumer of an object, with the contract specified by the names in the interface namespace alone.</p>
<p>If the compile-time type of the base object is not an interface type, an unqualified reference will use the currently open namespaces (which includes public) to create a multiname in the normal way. Again, ambiguous references can be explicitly qualified with the interface name to avoid conflicts.</p>



  <h1>10.2.2 Inheritance of interface methods</h1>
<p>The rules for implementing an inherited interface method are the same as the rules for overriding an inherited class method. Specifically, the name of the method, number and type of the parameters, and return type must match exactly. </p>
<p>It is a verification error if a class implements an interface method with a method whose name matches, but the parameter count or types or return type do not match. It is a verifier error if a class inherits an interface method that it does not implement.</p>



  <h1>10.3 Interface example</h1>
<p>The following example shows how interfaces are defined and used.</p>
<div class="listing">
<pre>
interface T 
{
    function f()
}

interface U 
{
    function f()
    function g()
}

interface V extends T,U 
{
    function h()
}

class A implements V 
{
    public function f() {}   // implements {T,U}::f
    public function g() {}   // implements {U}::g
    public function h() {}   // implements {V}::h
}

var a : A = new A
var t : T = a
var u : U = a
var v : V = a

t.f()     // {T}::f referenced, T::f matched
u.g()     // {U}::g referenced, U::g matched
v.f()     // {T,U,V}::f referenced, {T,U}::f matched
v.g()     // {T,U,V}::g referenced, U::g matched
v.h()     // {T,U,V}::h referenced, V::h matched
a.f()     // {public,…}::f referenced, public::f matched

var o = a

o.f()     // {public,…}::f referenced, public::f matched
</pre>
</div>
<p>A few highlights of this example:</p>
<ul>
<li>An implementing class must use <code>public</code> as an attribute to make the method implement all interface methods with a matching identifier.</li>
  <li>The static type of the base object of a reference controls which interface names are open in that reference if that type is an interface type.</li>
</ul>
<h1>11 Packages</h1>
<p>A package definition introduces a top-level namespace, suitable for organizing collections of type definitions into APIs.</p>
<p>Unlike ordinary namespaces (hereafter referred to simply as namespaces), a package is a pure compile-time construct. A package directive qualifies the names of properties defined inside of it at compile time; references to a package's member definitions are given fully qualified names at compile time.</p>
<div class="listing">
<pre>
package mx.core 
{
    class UIObject extends ...
    {
    }

    .
    .
    .
}
</pre>
</div>
<p>In this example, the fully qualified name for <code>UIObject</code> is <code>mx.core.UIObject</code>. An unqualified reference to <code>UIObject</code> will be fully qualified as <code>mx.core.UIObject</code> by the compiler.</p>
<p>Package definitions may be discontinuous; the definition of a package may be spread over multiple package definitions, possibly in multiple source files.</p>
<p>The semantics of loading packages is outside of the language definition. The compiler and virtual machine will have access to the package definitions in files that have been loaded by the embedding tool or runtime.</p>



  <h1>11.1 Package namespace</h1>
<p>The namespace name (the string used for equality comparision) of a package is the sequence of characters of its name. For example, the package in:</p>
<div class="listing">
<pre>
package mx.core {
    .
    .
    .
}
</pre>
</div>
<p>is given the namespace name <code>"mx.core"</code>.</p>
<p>Package names are used to:</p>
<ul>
<li>Qualify the names of top-level definitions in a package</li>
  <li>Qualify the names of references to those definitions</li>
  <li>Import names into other packages.</li>
</ul>
<div class="listing">
<pre>
package acme.core 
{
    public class Widget { }    // qualifies Widget
}

import acme.core.*             // make visible all names in acme.core
var widget : acme.core.Widget  // distinguishes a reference to Widget
</pre>
</div>
<p>Packages exist only at compile time. The static existence of packages allows us to give them certain properties that would not be possible if they could be manipulated at runtime. In particular:</p>
<ul>
<li>Package names may have embedded dots.</li>
  <li>Fully qualified package references may and must be expressed using the dot operator rather than the usual :: syntax for qualified names</li>
</ul>
<p>But because there is no runtime value for a package name, packages cannot be aliased or otherwise used in an expression that uses a runtime value. </p>
<p>When encountered in a valid context by the compiler, the meaning of a package name becomes fixed; any interpretation at runtime is no longer possible.</p>
<p>For this reason, a package name always shadows locally defined names, independent of the scope chain, when that package name is used on the left hand side of a dot operator.</p>
<div class="listing">
<pre>
package p 
{
    public var x = 10
}
import p.x
function f()
{
    var p = { x : 20 }
    trace(p.x)   // traces 10
}
f()
</pre>
</div>
<p>The following strict errors affect packages:</p>
<ul>
<li>It is a strict error to import a package that cannot be found.</li>
  <li>It is a strict error to reference a package property that cannot be found in an imported package.</li>
</ul>
<h1>11.2 Package members</h1>
<p>Definitions with the <code>public</code> attribute inside a package definition are implicitly qualified by the package namespace. Every kind of definition except for package definitions may appear directly inside a package definition, including variable, function, namespace, class, and interface definitions.</p>



  <h1>11.2.1 Package property attributes</h1>
<p>The visibility of a name defined inside of a package is controlled by the attributes that appear in that definition. Allowed attributes include the following:</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>public</p>
    </td>
    <td>
      <p>Qualified by the package namespace</p>
    </td>
  </tr>
<tr>
<td>
      <p>internal</p>
    </td>
    <td>
      <p>Qualified by the internal namespace for the current package [default]</p>
    </td>
  </tr>
</table>
<p>It is a syntax error for more than one of these attributes to appear in a definition.</p>



  <h1>11.3 Package import</h1>
<p>The names of package members are made visible inside an external scope with an <code>import</code> directive. For example, the following code makes all public names defined in the package mx.core visible inside any scope that contains this directive:</p>
<div class="listing">
<pre>
import mx.core.*
</pre>
</div>
<p>Individual names can be imported using an <code>import</code> directive with the fully qualified name to be imported. For example, the following code has the effect of making the class mx.core.Image, but no other names defined inside package mx.core, visible to an unqualified reference.</p>
<div class="listing">
<pre>
import mx.core.Image
</pre>
</div>
<p>References to package members are fully qualified using the dot operator. When the meaning of a simple name is ambiguous, a fully qualified name can be used to indicate the intended binding. For example:</p>
<div class="listing">
<pre>
import mx.core.*
import player.core.*

new Image    // error, mx.core.Image or player.core.Image?
new player.core.Image   // okay
</pre>
</div>
<p>Visibility of package members outside of a package is controlled by access control namespaces. The default namespace of a package member is package internal. For example:</p>
<div class="listing">
<pre>
package acme.core 
{
    public class Widget { }
    class WidgetImpl {}    // default namespace is internal
}

import acme.core.*
new WidgetImpl   // error, cannot find WidgetImpl
new Widget       // okay, public names are always visible
</pre>
</div>
<p>In this example, <code>class WidgetImpl</code> is in the internal package namespace for package <code>acme.core</code>. This namespace is always open inside of any definition of package <code>acme.core</code>, and never open or accessible outside of a definition of <code>acme.core</code>.</p>



  <h1>11.3.1 Single name aliases</h1>
<p>A name alias can be provided for single name import directives to avoid ambiguity of unqualified references, as shown in the following code:</p>
<div class="listing">
<pre>
package acme.core 
{
    public class Widget { }
}

package mx.core 
{
    public class Widget { }
}

import AcmeWidget = acme.core.Widget
import MxWidget = mx.core.Widget
new AcmeWidget
new MxWidget
</pre>
</div>
<p>When an alias is specified, the original fully qualified name can be used to refer to the imported definition. It is also possible to use the original unqualified name as long as the resulting reference is not ambiguous.</p>



  <h1>11.4 Unnamed package</h1>
<p>The unnamed package is defined by a package definition with no name specified, as shown in the following code:</p>
<div class="listing">
<pre>
package 
{
}
</pre>
</div>
<p>The unnamed package is implicitly imported by all other packages and global code outside of any package. This makes it convenient for casual sharing of definitions between programs by making public definitions in the unnamed package always visible.</p>



  <h1>12 Namespaces</h1>
<p>Namespaces are used to qualify names. ECMAScript for XML (E4X) introduced the idea of explicitly qualifying names to reference properties of an XML object. XML namespaces allow markup with various meanings, but potentially conflicting names, to be intermixed in a single use. Packages in ActionScript 3.0 provide such a capability. XML namespaces also allow names to be individually qualified to create sub-vocabularies relating to concerns secondary to the main purpose of the markup. Namespaces in ActionScript 3.0 provide this capability, that is, controlling the visibility of names independent of the structure of the program. This is useful for giving trusted code special access privileges and for distinguishing the meaning of a name between versions and uses.</p>



  <h1>12.1 Namespace values</h1>
<p>Namespace definitions introduce a constant fixed property of type Namespace into the defining scope. The property is initialized to an implicit or explicit value. Regardless of how it is initialized, a namespace value consists of a namespace name used for equality comparison.</p>
<p>The following example shows the definition of several namespaces:</p>
<div class="listing">
<pre>
namespace N1
namespace N2 = N1
namespace N3 = 'http://www.ecma-international.org/namespace'
</pre>
</div>
<p><code>N1</code> is given an anonymous namespace name. <code>N2</code> is an alias of <code>N1</code>. <code>N3</code> is given a namespace with the namespace name of  <code>'http://www.ecma-international.org/namespace'</code>. When created by a namespace definition, the prefix of a namespace is initialized to the value undefined.</p>
<p>The set of attributes that may be used on a namespace definition is the same as the set that can be used on a variable definition.</p>



  <h1>12.2 Namespaces as attributes</h1>
<p>When used as an attribute of a definition, a namespace specifies the namespace qualifier of that definition's name:</p>
<div class="listing">
<pre>
namespace N1
namespace N2
N1 var x : int = 10
N2 var x : String = "hello"
</pre>
</div>
<p>Here, two distinct variables are defined--one with the qualified name <code>N1::x</code> and the other with the qualified name <code>N2::x</code>. Referencing code can refer to one or the other of these names by explicitly qualifying references to <code>x</code> or by adding one or the other namespace to the set of open namespaces.</p>
<p>It is an error to use a user-defined namespace as an attribute except in the top-level of a class definition.</p>



  <h1>12.3 Namespaces as qualifiers</h1>
<p>References to a name qualified by a namespace can be explicitly qualified by that namespace:</p>
<div class="listing">
<pre>
namespace N1
namespace N2
N1 var x : int = 10
N2 var x : String = "hello"

trace(N1::x)
</pre>
</div>
<p>In this case, the qualification is necessary because an unqualified reference to <code>x</code> would not match any visible definition of x, and would therefore result in a runtime exception. </p>



  <h1>12.4 Open namespaces</h1>
<p>The set of open namespaces determines the visibility of unqualified references. If the qualifier of a name is not in the set of open namespaces, it will not be visible to an unqualified reference. Namespaces are added to the list of open namespaces by the <code>use namespace</code> directive. Building on the previous example, the namespace <code>N1</code> is added to the set of open namespaces:</p>
<div class="listing">
<pre>
namespace N1
namespace N2
N1 var x : int = 10
N2 var x : String = "hello"
use namespace N1
trace(x)  // trace 10
</pre>
</div>
<p>The unqualified reference to <code>x</code> matches any name that has the identifier <code>x</code> and is qualified by one of the open namespaces, in this case <code>N1::x</code>.</p>
<p>It is a runtime error for more than one name to match an unqualified reference.</p>
<p>The set of open namespaces includes any namespace that is explicitly used in that block or an outer nested block, as well as the public, internal, protected, and private namespaces that are implicitly open in various contexts.</p>
<p>Bindings of explicitly used namespaces are preferred over names in the public namespace. This allows a public name to be given an open user-defined namespace without making unqualified references ambiguous:</p>
<div class="listing">
<pre>
namespace N1
N1 var x : int = 10
public var x : String = "hello"
use namespace N1
trace(x)  // okay, matches N1::x, even though public::x is also visible
</pre>
</div>


  <h1>12.5 Namespace examples</h1>



  <h1>12.5.1 Access control</h1>
<div class="listing">
<pre>
class A {
    private namespace Key
    private var friends = [ B ]
    function beMyFriend( suitor ) {
        for each( friend in friends )
        {
            if( suitor is friend ) return Key
        }
        return null
    }
    Key function makeMyDay() 
    { 
        trace("making my day") 
    } 
}

class B {
    function befriendAnA(a:A) {
        var key : Namespace = a.beMyFriend(this)
        if( key != null )
        {
            a.key::makeMyDay()
        }
    }
}
</pre>
</div>


  <h1>12.5.2 Version control</h1>
<div class="listing">
<pre>
package p {
public namespace V2
public class A {
    public function m() {}
    V2 function m() {}
}
}

import p.v1
import p.v2
import p.A

// version 1

class B extends A 
{
    public function m() {}
}

// version 2

class B extends A 
{
    public function m() {}
    V2 function m() {}
}

use namespace p.V2  // open p.V2, prefer it over public
var a : A = new B
a.m()
</pre>
</div>


  <h1>12.5.3 Vocabulary control</h1>
<p>Namespace definitions allow multiple vocabularies to be defined in a single class. This is a kind of polymorphism that is independent of the class abstraction. It is useful when you have common functionality that has a more than one public interface. You could use subclasses to express the overridden behavior, but if there is more than one vocabulary that needs to be mixed in, the number of combinations quickly explodes. </p>
<div class="listing">
<pre>
package p {
public namespace French
public namespace Vegan
public class Person {
    public function sayIt() { /* say it in English */ }
    French function sayIt() { /* say it in French */ }
    public function eatIt() { /* eat steak */ }
    Vegan  function eatIt() { /* eat vegan */
}
}

import p.*

var person = new Person()

{
    use namespace French
    use namespace Vegan
    person.sayIt()   // speak French
    person.eatIt()   // eat vegan
}

{
    person.sayIt()   // speak English
    person.eatIt()   // eat meat
}
</pre>
</div>


  <h1>13 Lexical Structure</h1>



  <h1>13.1 Lexical </h1>
<p>Lexical keywords are removed from the available program namespace during scanning. It is a syntax error to use any of these names except as indicated by the grammar. Syntactic keywords appear to the lexical scanner as identifier tokens, but are given special meaning in certain contexts by the parser.</p>
<p>The following list contains all keywords:</p>
<div class="listing">
<pre>
as break case catch class const continue default delete do else extends false finally for function if implements import in instanceof interface internal is native new null package private protected public return super switch this throw to true try typeof use var void while with
</pre>
</div>
<p>The following list contains all identifiers that are syntactic keywords:</p>
<div class="listing">
<pre>
each get set namespace include dynamic final native override static
</pre>
</div>


  <h1>13.2 Syntactic</h1>
<p>Identifiers with special meaning become keywords in certain syntactic contexts:</p>
<ul>
<li>In a for-each-in statement between the 'for' token and the '(' token:    <p><code>each</code>   </p>  </li>
  <li>In a function definition between the 'function' token and an identifier token:    <p><code>get set</code>   </p>  </li>
  <li>As the first word of a directive:    <p><code>namespace include</code></p>  </li>
  <li>In an attribute list or wherever an attribute list can be used:    <p><code>dynamic final native override static</code></p>  </li>
</ul>
<p>It is a syntax error to use a syntactic keyword in a context where it is treated as a keyword:</p>
<div class="listing">
<pre>
namespace = "hello"
namespace()
</pre>
</div>
<p>In these cases, the grammar requires an identifier after the <code>namespace</code> keyword.</p>



  <h1>14 Expressions</h1>
<p>The syntax in this section contains the following superscript and subscript symbols:</p>
<ul>
<li>The <code>opt</code> subscript is attached to symbols that are optional.</li>
  <li>The <code>allowIn</code> superscript is attached to nonterminals that can be defined with a production rule that contains the <code>in</code> operator.</li>
  <li>The <code>noIn</code> superscript is attached to nonterminals with definitions that do not include a production rule that contains the <code>in</code> operator. This superscript is necessary to avoid conflicts between the <code>in</code> operator as part of a relational expression and the <code>in</code> operator as part of a <code>for</code> statement.</li>
  <li>The <code>β</code> superscript is shorthand notation that denotes a nonterminal with a pair of definitions: an <code>allowIn</code> version and a <code>noIn</code> version.</li>
</ul>
<hr>
<h1>14.1 Identifiers</h1>
<p>Identifiers may be either simple identifiers or qualified identifiers. Qualified identifiers result in a single name consisting of a namespace and a string. The string is specified by an expression or a literal identifier. The namespace is specified by an expression that precedes the <code>::</code> punctuator. Simple identifiers result in one or more names that consist of the identifier string and each of the namespaces open in the scope of the expression. The resulting name value(s) are used to construct a Reference value specified by a larger expression.</p>
<h4>
<a name="wp141456"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Identifier</p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p>Identifier</p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p><strong><code>dynamic</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p><strong><code>each</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p><strong><code>get</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p><strong><code>include</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p><strong><code>namespace</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p><strong><code>set</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p><strong><code>static</code></strong></p>    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>PropertyIdentifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>*</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Qualifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>PropertyIdentifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ReservedNamespace</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>SimpleQualifiedIdentifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>PropertyIdentifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Qualifier :: PropertyIdentifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Qualifier :: Brackets</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ExpressionQualifiedIdentifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ParenExpression :: PropertyIdentifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ParenExpression :: Brackets</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>NonAttributeQualifiedIdentifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>SimpleQualifiedIdentifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ExpressionQualifiedIdentifier</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>QualifiedIdentifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>@ Brackets</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>@ NonAttributeQualifiedIdentifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>NonAttributeQualifiedIdentifier</p>
    </td>
  </tr>
</table>
<p>Expressions of the form</p>
<div class="listing">
<pre>
SimpleQualifiedIdentifier : Qualifier :: PropertyIdentifier
SimpleQualifiedIdentifier : ParenExpression :: PropertyIdentifier
</pre>
</div>
<p>are syntactically rewritten as</p>
<div class="listing">
<pre>
SimpleQualifiedIdentifier : Qualifier :: Brackets
SimpleQualifiedIdentifier : ParenExpression:: Brackets
</pre>
</div>
<p>respectively, where the expression between Brackets is a string literal with the same sequence of characters as the PropertyIdentifier.</p>
<h4>
<a name="wp128187"></a>Verification</h4>
<p>Identifier : Identifier</p>
<p>Identifier : each</p>
<p>Identifier : get</p>
<p>Identifier : include</p>
<p>Identifier : namespace</p>
<p>Identifier : set</p>
<ul>
<li>Return the type String</li>
</ul>
<p>PropertyIdentifier : Identifier</p>
<p>Qualifier : PropertyIdentifier</p>
<p>Qualifier : ReservedNamespace</p>
<p>SimpleQualifiedIdentifier : PropertyIdentifier</p>
<ul>
<li>Return the result of verifying the non-terminal symbol on right-hand side of the production </li>
</ul>
<p>SimpleQualifiedIdentifier : Qualifier :: PropertyIdentifier</p>
<ul>
<li>Let qual be the result of verifying Qualifier</li>
  <li>Call verifyType(qual,Namespace)</li>
  <li>Return the type Name</li>
</ul>
<p>SimpleQualifiedIdentifier : Qualifier :: Brackets</p>
<ul>
<li>Let qual be the result of verifying Qualifier</li>
  <li>Call verifyType(qual,Namespace)</li>
  <li>Let expr be the result of verifying Brackets</li>
  <li>If expr is of type Name    <ul>
<li>Throw a VerifierError exception</li>
    </ul>
</li>
  <li>Return the type Name</li>
</ul>
<p>ExpressionQualifiedIdentifier : ParenExpression :: PropertyIdentifier</p>
<ul>
<li>Let qual be the result of verifying ParenExpression</li>
  <li>Call verifyType(qual,Namespace)</li>
  <li>Return the type Name</li>
</ul>
<p>ExpressionQualifiedIdentifier : ParenExpression :: Brackets</p>
<ul>
<li>Let qual be the result of verifying ParenExpression</li>
  <li>Call verifyType(qual,Namespace)</li>
  <li>Let expr be the result of verifying Brackets</li>
  <li>If expr is of type Name    <ul>
<li>Throw a VerifyError exception</li>
    </ul>
</li>
  <li>Return the type Name</li>
</ul>
<p>NonAttributeQualifier : SimpleQualifiedIdentifier</p>
<p>NonAttributeQualifier : ExpressionQualifiedIdentifier</p>
<ul>
<li>Return the result of verifying the non-terminal symbol on right-hand side of the production </li>
</ul>
<p>QualifiedIdentifier : @ Brackets</p>
<ul>
<li>Verify Brackets</li>
  <li>Return the type Name</li>
</ul>
<p>QualifiedIdentifier : @ NonAttributeQualifiedIdentifier</p>
<p>QualifiedIdentifier : NonAttributeQualifiedIdentifier</p>
<ul>
<li>Verify NonAttributeQualifiedIdentiifer</li>
  <li>Return the type Name</li>
</ul>
<h4>
<a name="wp128251"></a>Evaluation</h4>
<p>Identifier : Identifier</p>
<p>Identifier : each</p>
<p>Identifier : get</p>
<p>Identifier : include</p>
<p>Identifier : namespace</p>
<p>Identifier : set</p>
<ul>
<li>Return a new String value consisting of the sequence of characters of the token on the right-hand side of the production</li>
</ul>
<p>PropertyIdentifier : Identifier</p>
<ul>
<li>Return the result of evaluating Identifier </li>
  <li>PropertyIdentifier : *</li>
  <li>Return the new instance String("*") </li>
</ul>
<p>Qualifier : PropertyIdentifier</p>
<p>Qualifier : ReservedNamespace</p>
<p>SimpleQualifiedIdentifier : PropertyIdentifier</p>
<ul>
<li>Return the result of evaluating the non-terminal symbol on right-hand side of the production </li>
</ul>
<p>SimpleQualifiedIdentifier : Qualifier :: PropertyIdentifier</p>
<ul>
<li>Let qual be the result of evaluating Qualifier</li>
  <li>Let str be the result of evaluating PropertyIdentifier</li>
  <li>Return the new instance Name(qual,str,false)</li>
</ul>
<p>SimpleQualifiedIdentifier : Qualifier :: Brackets</p>
<ul>
<li>Let qual be the result of evaluating Qualifier</li>
  <li>Let expr be the result of evaluating Brackets</li>
  <li>If expr is of type Name    <ul>
<li>Throw a TypeError exception</li>
    </ul>
</li>
  <li>Let str be the result of calling String(expr)</li>
  <li>Let name be the instance Name(qual,str,false)</li>
  <li>Return name</li>
</ul>
<p>ExpressionQualifiedIdentifier : ParenExpression :: PropertyIdentifier</p>
<ul>
<li>Let qual be the result of evaluating ParenExpression</li>
  <li>Let str be the result of evaluating PropertyIdentifier</li>
  <li>Return the new instance Name(qual,str,false)</li>
</ul>
<p>ExpressionQualifiedIdentifier : ParenExpression :: Brackets</p>
<ul>
<li>Let qual be the result of evaluating ParenExpression</li>
  <li>Let expr be the result of evaluating Brackets</li>
  <li>If expr is of type Name    <ul>
<li>Throw a TypeError exception</li>
    </ul>
</li>
  <li>Let str be the result of calling String(expr)</li>
  <li>Let name be the instance Name(qual,str,false)</li>
  <li>Return name</li>
</ul>
<p>NonAttributeQualifier : SimpleQualifiedIdentifier</p>
<p>NonAttributeQualifier : ExpressionQualifiedIdentifier</p>
<ul>
<li>Return the result of evaluating the non-terminal symbol on right-hand side of the production </li>
</ul>
<p>QualifiedIdentifier : @ Brackets</p>
<ul>
<li>Let expr be the result of evaluating Brackets</li>
  <li>If expr is of type Name    <ul>
<li>Let name be the set consisting of expr</li>
    </ul>
</li>
  <li>Else    <ul>
<li>Let str be the result of calling String(expr)</li>
      <li>Let namespaces be the result of calling openNamespaces(ctx)</li>
      <li>Let name be the result of makeMultiname(namespaces,str)</li>
    </ul>
</li>
  <li>Call makeAttributeName(name)</li>
  <li>Return name</li>
</ul>
<p>QualifiedIdentifier : @ NonAttributeQualifiedIdentifier</p>
<ul>
<li>Let name be the result of evaluating NonAttributeQualifiedIdentifier</li>
  <li>Call makeAttributeName (name)</li>
  <li>Return name</li>
</ul>
<p>QualifiedIdentifier : NonAttributeQualifiedIdentifier</p>
<ul>
<li>Let name be the result of evaluating NonAttributeQualifiedIdentifier</li>
  <li>Return name</li>
</ul>
<h1>14.2 Primary expressions</h1>
<h4>
<a name="wp128338"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>PrimaryExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>null</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>true</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>false</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Number</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>this</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RegularExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>QualifiedIdentifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLInitializer</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ReservedNamespace</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ParenListExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ArrayInitialiser</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ObjectInitialiser</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>FunctionExpression</p>
    </td>
  </tr>
</table>
<p>A PrimaryExpression can be used wherever a FullPostfixExpression or a FullNewSubExpression can be used. This includes object creation, property access, and function invocation expressions.</p>
<h4>
<a name="wp128406"></a>Verifition</h4>
<p>PrimaryExpression : null</p>
<ul>
<li>Return the type Null</li>
</ul>
<p>PrimaryExpression : true</p>
<p>PrimaryExpression : false</p>
<ul>
<li>Return the type Boolean</li>
</ul>
<p>PrimaryExpression : Number</p>
<ul>
<li>Return the type Number</li>
</ul>
<p>PrimaryExpression : String</p>
<ul>
<li>Return the type String</li>
</ul>
<p>PrimaryExpression : RegularExpression</p>
<ul>
<li>Return the type RegExp</li>
</ul>
<p>PrimaryExpression : QualifiedIdentifier</p>
<ul>
<li>Return the result of verifying QualifiedIdentifier</li>
</ul>
<p>PrimaryExpression : XMLInitialiser</p>
<p>PrimaryExpression : ReservedNamespace</p>
<p>PrimaryExpression : ParenListExpression</p>
<p>PrimaryExpression : ArrayInitialiser</p>
<p>PrimaryExpression : ObjectInitialiser</p>
<p>PrimaryExpression : FunctionExpression</p>
<ul>
<li>Return the result of verifying the non-terminal symbol on the right-hand side of the production</li>
</ul>
<p>PrimaryExpression : this</p>
<ul>
<li>Let frame be the immediately enclosing ParameterFrame</li>
  <li>If frame is none    <ul>
<li>Throw a VerifyError</li>
    </ul>
</li>
  <li>Return the result of typeOfThis(frame)</li>
</ul>
<h4>
<a name="wp128449"></a>Evaluation</h4>
<p>PrimaryExpression : null</p>
<ul>
<li>Return the value <code>null</code>
</li>
</ul>
<p>PrimaryExpression : true</p>
<ul>
<li>Return the value <code>true</code>
</li>
</ul>
<p>PrimaryExpression : false</p>
<ul>
<li>Return the value <code>false</code>
</li>
</ul>
<p>PrimaryExpression : Number</p>
<ul>
<li>Return the Number value produced by lexical analysis of Number</li>
</ul>
<p>PrimaryExpression : String</p>
<ul>
<li>Return the String value produced by lexical analysis of String</li>
</ul>
<p>PrimaryExpression : this</p>
<ul>
<li>Let frame be the immediately enclosing ParameterFrame</li>
  <li>Return the value of this associated with frame</li>
</ul>
<p>PrimaryExpression : RegularExpression</p>
<ul>
<li>Return the RegExp result of evaluating the expression produced by lexical analysis of RegularExpression</li>
</ul>
<p>PrimaryExpression : QualifiedIdentifier</p>
<ul>
<li>Let name be the result of evaluating QualifiedIdentifier</li>
  <li>Let ref be an instance Reference(null,name,null)</li>
  <li>Return ref</li>
</ul>
<h1>14.3 Reserved namespace expressions</h1>
<h4>
<a name="wp128488"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ReservedNamespace</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>public</code></strong></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>private</code></strong></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>protected</code></strong></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>internal</code></strong></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp128514"></a>Verification</h4>
<p>ReservedNamespace : public</p>
<ul>
<li>Return the value of type Namespace</li>
</ul>
<p>ReservedNamespace : private</p>
<p>ReservedNamespace : protected</p>
<ul>
<li>If ReservedNamespace is not enclosed in a ClassDefinition    <ul>
<li>Throw a VerifyError</li>
    </ul>
</li>
  <li>Return the value of type Namespace</li>
</ul>
<p>ReservedNamespace : internal</p>
<ul>
<li>If ReservedNamespace is not enclosed in a PackageDefinition    <ul>
<li>Throw a VerifyError</li>
    </ul>
</li>
  <li>Return the value of type Namespace</li>
</ul>
<h4>
<a name="wp128533"></a>Evaluation</h4>
<p>ReservedNamespace : public</p>
<ul>
<li>Return the public namespace</li>
</ul>
<p>ReservedNamespace : private</p>
<ul>
<li>Return the private namespace of the enclosing class</li>
</ul>
<p>ReservedNamespace : protected</p>
<ul>
<li>Return the protected namespace of the enclosing class</li>
</ul>
<p>ReservedNamespace : internal</p>
<ul>
<li>Return the internal namespace of the enclosing package</li>
</ul>
<h1>14.4 Parenthesized expressions</h1>
<h4>
<a name="wp128553"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ParenExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>( AssignmentExpression<sup>allowIn</sup> )</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ParenListExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ParenExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>( ListExpression<sup>allowIn</sup> , AssignmentExpression<sup>allowIn</sup> )</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp128584"></a>Verification</h4>
<p>ParenExpression : ( AssignmentExpression<sup>allowIn</sup> )</p>
<ul>
<li>Return the result of verifying AssignmentExpression</li>
</ul>
<p>ParenListExpression : ( ListExpression<sup>allowIn</sup> , AssignmentExpression<sup>allowIn</sup> )</p>
<ul>
<li>Verify ListExpression</li>
  <li>Return the result of verifying AssignmentExpression</li>
</ul>
<h4>
<a name="wp128595"></a>Evaluation</h4>
<p>ParenExpression : ( AssignmentExpression<sup>allowIn</sup> )</p>
<ul>
<li>Return the result of evaluating AssignmentExpression</li>
</ul>
<p>ParenListExpression : ( ListExpression<sup>allowIn</sup> , AssignmentExpression<sup>allowIn</sup> )</p>
<ul>
<li>Evaluate ListExpression</li>
  <li>Let ref be the result of evaluating AssignmentExpression</li>
  <li>Return the result of readReference(ref)</li>
</ul>
<h1>14.5 Function expression</h1>
<h4>
<a name="wp142251"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FunctionExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>function</code></strong> FunctionCommon</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>function</code></strong> Identifier FunctionCommon</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp128627"></a>Verification</h4>
<p>FunctionExpression : function FunctionCommon</p>
<p>FunctionExpression : function Identifier FunctionCommon</p>
<ul>
<li>Return the result of verifying FunctionCommon</li>
</ul>
<h4>
<a name="wp142304"></a>Evaluation</h4>
<p>FunctionExpression : function FunctionCommon</p>
<ul>
<li>Return the result of evaluating FunctionCommon</li>
</ul>
<p>FunctionExpression : function Identifier FunctionCommon</p>
<ul>
<li>Let obj be a new instance of Object</li>
  <li>Push obj onto the scope chain</li>
  <li>Let fun be the result of evaluating FunctionCommon</li>
  <li>Let id be the result of evaluating Identifier</li>
  <li>Add a property to obj with the name id and the value fun that is not writable and not deletable</li>
  <li>Pop obj from the scope chain</li>
  <li>Return fun</li>
</ul>
<h1>14.6 Object initialiser</h1>
<h4>
<a name="wp128652"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ObjectInitialiser</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>{ FieldList }</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FieldList</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>NonemptyFieldList</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>NonemptyFieldList</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>LiteralField</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>LiteralField , NonemptyFieldList</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>LiteralField</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>FieldName : AssignmentExpression<sup>allowIn</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FieldName</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>NonAttributeQualifiedIdentifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Number</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp128730"></a>Verification</h4>
<p>ObjectInitialiser : { FieldList }</p>
<ul>
<li>Return the result of verifying FieldList</li>
</ul>
<p>FieldList : empty</p>
<ul>
<li>Do nothing</li>
</ul>
<p>FieldList : NonemptyFieldList</p>
<ul>
<li>Verify NonemptyFieldList</li>
</ul>
<p>NonemptyFieldList : LiteralField</p>
<ul>
<li>Verify LiteralField</li>
</ul>
<p>NonemptyFieldList : LiteralField , NonemptyFieldList</p>
<ul>
<li>Verify LiteralField</li>
  <li>Verify NonemptyFieldList</li>
</ul>
<p>LIteralField : FieldName : AssignmentExpression</p>
<ul>
<li>Verify FieldName</li>
  <li>Verify AssignmentExpression</li>
</ul>
<p>FieldName : NonAttributeQualifiedIdentifier</p>
<ul>
<li>Verify NonAttributeQualifiedIdentifier</li>
</ul>
<p>FieldName : String</p>
<p>FieldName : Number</p>
<ul>
<li>Do nothing</li>
</ul>
<h4>
<a name="wp128767"></a>Evaluation</h4>
<p>ObjectInitialiser : { FieldList }</p>
<ul>
<li>Let obj be the result of creating a new Object instance</li>
  <li>Return the result of evaluating FieldList with argument obj</li>
</ul>
<p>FieldList : empty</p>
<ul>
<li>Return the value of the argument obj</li>
</ul>
<p>FieldList : NonemptyFieldList</p>
<ul>
<li>Evaluate NonemptyFieldList with argument obj</li>
</ul>
<p>NonemptyFieldList : LiteralField</p>
<ul>
<li>Evaluate LiteralField with argument obj</li>
</ul>
<p>NonemptyFieldList : LiteralField , NonemptyFieldList</p>
<ul>
<li>Evaluate LiteralField with argument obj</li>
  <li>Evaluate NonemptyFieldList with argument obj</li>
</ul>
<p>LIteralField : FieldName : AssignmentExpression</p>
<ul>
<li>Let name be the result of evaluating FieldName</li>
  <li>Let ref be the result of evaluating AssignmentExpression</li>
  <li>Let val be the value of referenceRead(ref)</li>
  <li>Call objectWrite(obj,name,val)</li>
</ul>
<p>FieldName : NonAttributeQualifiedIdentifier</p>
<ul>
<li>Return the result of evaluating NonAttributeQualifiedIdentifier</li>
</ul>
<p>FieldName : String</p>
<ul>
<li>Return the value of String</li>
</ul>
<p>FieldName : Number</p>
<ul>
<li>Let num be the value of Number</li>
  <li>Return the result of calling String(num)</li>
</ul>
<h1>14.7 Array initialiser</h1>
<p>An array initialiser is an expression describing the initialisation of an Array object, written in a form of a literal. It is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets. The elements need not be literals; they are evaluated each time the array initialiser is evaluated.</p>
<p>Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an AssignmentExpression (such as a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined.</p>
<h4>
<a name="wp128817"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ArrayInitialiser</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>[ ElementList ]</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ElementList</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>LiteralElement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>, ElementList</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>LiteralElement , ElementList</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>LiteralElement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>AssignmentExpression<sup>allowIn</sup></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp128867"></a>Verification</h4>
<p>An ArrayInitialiser is verified by verifying all non-terminals on the right-hand side of each production. The result of verifying an ArrayInitialiser is the type Array.</p>
<h4>
<a name="wp128871"></a>Evaluation</h4>
<p>ArrayInitialiser expressions are evaluated as described in ECMA-262 edition 3.</p>



  <h1>14.8 XML initialisers</h1>
<p>An XML initialiser is an expression describing the initialisation of an XML object, written in a form of a literal. It may specify an XML element, an XML comment, an XML PI, or a CDATA section using ordinary XML syntax. For XML elements, it provides the name, attributes and properties of an XML object.</p>
<h4>
<a name="wp142645"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>XMLInitialiser</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLMarkup</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLElement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>&lt;  &gt;  XMLElementContent  &lt;/  &gt;</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>XMLElement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>&lt; XMLTagContent XMLWhitespace<sub>opt</sub>/&gt;</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>&lt; XMLTagContent XMLWhitespace<sub>opt</sub>&gt; XMLElementContent &lt;/ XMLTagName XMLWhitespace<sub>opt</sub>&gt;</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>XMLTagContent</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLTagName XMLAttributes</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>XMLTagName</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>{ Expression }</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLName</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>XMLAttributes</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLWhitespace { Expression }</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLAttribute XMLAttributes</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>XMLAttribute</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLWhitespace XMLName XMLWhitespace<sub>opt</sub> = XMLWhitespace<sub>opt</sub> { Expression }</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLWhitespace XMLName XMLWhitespace<sub>opt</sub> = XMLWhitespace<sub>opt</sub> XMLAttributeValue</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>XMLElementContent</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>{ Expression } XMLElementContent</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLMarkup XMLElementContent</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLText XMLElementContent</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>XMLElement XMLElementContent</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
</table>
<p>See the ECMAScript for XML (E4X) specification (ECMA-357 edition 2) for definitions of XMLMarkup, XMLText, XMLName, XMLWhitespace and XMLAttributeValue.</p>
<h4>
<a name="wp129033"></a>Verification</h4>
<p>An XMLInitialiser is verified by verifying all non-terminals on the right hand side of each production. The result of verifying an XMLInitialiser is the type XML.</p>
<h4>
<a name="wp129037"></a>Evaluation</h4>
<p>XMLInitialiser expressions are evaluated as described in ECMA-357 edition 2.</p>



  <h1>14.9 Super expression</h1>
<p>SuperExpression limits the binding of a reference to a property of the base class of the current method. The value of the operand must be an instance of the current class. If Arguments is specified, its value is used as the base object of the limited reference. If no Arguments is specified, the value of this is used as the base object.</p>
<h4>
<a name="wp129045"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>SuperExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>super</code></strong></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>super</code></strong> Arguments</p>
    </td>
  </tr>
</table>
<p><i>SuperExpression</i> may be used before a <i>PropertyOperator</i> in either a <i>FullPostfixExpression</i> or a <i>FullNewSubexpression</i>.</p>
<div class="listing">
<pre>
super.f(a,b,c)
super(o).f(a,b,c)
</pre>
</div>
<h4>
<a name="wp129068"></a>Verification</h4>
<p>SuperExpression : super</p>
<p>SuperExpression : super Arguments</p>
<ul>
<li>Let frame be the immediately enclosing ParameterFrame</li>
  <li>If frame is none    <ul>
<li>Throw a VerificationError</li>
    </ul>
</li>
  <li>Let type be the result of typeOfThis(frame)</li>
  <li>Let limit be type.super</li>
  <li>If Arguments is specified and not empty     <ul>
<li>Let obj be the result verifying Arguments</li>
      <li>Call verifyType(obj,limit)</li>
    </ul>
</li>
  <li>Return the type limit</li>
</ul>
<h4>
<a name="wp129084"></a>Evaluation</h4>
<p>SuperExpression : super</p>
<p>SuperExpression : super Arguments</p>
<ul>
<li>Let frame be the immediately enclosing ParameterFrame</li>
  <li>Let this be the value of frame.this</li>
  <li>Let type be the value of this.type</li>
  <li>Let limit be type.super</li>
  <li>If Arguments is empty or not specified     <ul>
<li>Let obj be the value of this</li>
    </ul>
</li>
  <li>Else     <ul>
<li>Let obj be the result of evaluating Arguments</li>
      <li>If obj.type is not a subtype of limit, then throw a TypeError</li>
    </ul>
</li>
  <li>Let obj be a new instance LimitedBase(obj,limit)</li>
</ul>
<h4>
<a name="wp129100"></a>Compatibility</h4>
<p>ActionScript 2.0 supports only the first form of <i>SuperExpression</i>. </p>
<div class="listing">
<pre>
super.f(a,b,c)
</pre>
</div>
<p>This is equivalent to the following ActionScript 2.0 code:</p>
<div class="listing">
<pre>
this.constructor.prototype.__proto__.f.apply(this,arguments);
</pre>
</div>
<p>This differs from ActionScript 3.0 depending on the value of <code>this</code>, and whether the value of <code>constructor</code>, <code>prototoype</code> or <code>__proto__</code> has been modified.</p>
<p>The second form of <i>SuperExpression</i> is included for future compatibility and completeness.</p>



  <h1>14.10 Postfix Expressions</h1>
<h4>
<a name="wp142855"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>PostfixExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>FullPostfixExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ShortNewExpression</p>
    </td>
  </tr>
</table>
<p>A PostfixExpression may be used in a UnaryExpression, before ++ or -- in another PostfixExpression on the left-hand side of an AssignmentExpression, or as a ForInBinding.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FullPostfixExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>PrimaryExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>FullNewExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>FullPostfixExpression PropertyOperator</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>SuperExpression PropertyOperator</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>FullPostfixExpression Arguments</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>FullPostfixExpression QueryOperator</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>PostfixExpression [no line break] ++</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>PostfixExpression [no line break] --</p>
    </td>
  </tr>
</table>
<p>A <i>FullPostfixExpression</i> may be used as a <i>PostfixExpression</i>, or before a <i>PropertyOperator</i> or an <i>Arguments</i> in another <i>FullPostfixExpression</i>.</p>
<h4>
<a name="wp129178"></a>Verification</h4>
<p>FullPostfixExpression : PrimaryExpression</p>
<p>FullPostfixExpression : FullNewExpression</p>
<ul>
<li>Return the result of verifying the right hand side of the production</li>
</ul>
<p>FullPostfixExpression : FullPostfixExpression PropertyOperator</p>
<ul>
<li>Let base be the result of verifying FullPostfixExpression</li>
  <li>Let name be result of verifying PropertyOperator</li>
  <li>Return the result of referenceType(base,name,null,false)</li>
</ul>
<p>FullPostfixExpression : SuperExpression PropertyOperator</p>
<ul>
<li>Let base be the result of verifying SuperExpression</li>
  <li>Let name be result of verifying PropertyOperator</li>
  <li>Return the result of referenceType(base.this,name,base.limit,false)</li>
</ul>
<p>FullPostfixExpression : FullPostfixExpression Arguments</p>
<ul>
<li>Let fun be the result of verifying FullPostfixExpression</li>
  <li>Let args be the result of verifying Arguments</li>
  <li>If isStrict()    <ul>
<li>Call verifyType(fun,Function)</li>
      <li>Let types be the value fun.types</li>
      <li>If args.length is not equal to types.length, throw a VerifyError exception</li>
      <li>For each type in args, call verifyType(args[i],types[i])</li>
    </ul>
</li>
  <li>Return the result of resultType(fun)</li>
</ul>
<p>FullPostfixExpression : FullPostfixExpression QueryOperator</p>
<ul>
<li>Let type be the result of verifying FullPostfixExpression</li>
  <li>Return the result of verifying QueryOperator passing the argument type</li>
</ul>
<p>FullPostfixExpression : PostfixExpression [no line break] ++</p>
<p>FullPostfixExpression : PostfixExpression [no line break] --</p>
<ul>
<li>Let type be the result of verifying PostfixExpression</li>
  <li>Call verifyType(type,Number)</li>
  <li>Return type Number</li>
</ul>
<h4>
<a name="wp129220"></a>Evaluation</h4>
<p>FullPostfixExpression : PrimaryExpression</p>
<ul>
<li>Return the result of evaluating PrimaryExpression</li>
</ul>
<p>FullPostfixExpression : FullNewExpression</p>
<ul>
<li>Return the result of evaluating FullNewExpression</li>
</ul>
<p>FullPostfixExpression : FullPostfixExpression PropertyOperator</p>
<ul>
<li>Let ref be the result of evaluating FullPostfixExpression</li>
  <li>Let base be the result of readReference(ref)</li>
  <li>Let name be the result of evaluating PropertyOperator</li>
  <li>Return the new instance Reference(base,name,null,false)</li>
</ul>
<p>FullPostfixExpression : SuperExpression PropertyOperator</p>
<ul>
<li>Let limited be the result of evaluating SuperExpression</li>
  <li>Return the new instance Reference(limited.this,name,limited.type,false)</li>
</ul>
<p>FullPostfixExpression : FullPostfixExpression QueryOperator</p>
<ul>
<li>Let ref be the result of evaluating FullPostfixExpression</li>
  <li>Let obj be the result of readReference(ref)</li>
  <li>Return the result of evaluating QueryOperator passing the argument obj</li>
</ul>
<p>FullPostfixExpression : FullPostfixExpression Arguments</p>
<ul>
<li>Let ref be the result of evaluating FullPostfixExpression</li>
  <li>Let args be the result of evaluating Arguments</li>
  <li>Return the result of callReference(ref,args)</li>
</ul>
<p>FullPostfixExpression : PostfixExpression [no line break] ++</p>
<ul>
<li>Let ref be the result of evaluating PostfixExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>Let num1 be the result of Number(val)</li>
  <li>Let num2 be the result of evaluating the expression num1 + 1</li>
  <li>Call writeReference(ref,num2)</li>
  <li>Return num1</li>
</ul>
<p>FullPostfixExpression : PostfixExpression [no line break] -</p>
<ul>
<li>Let ref be the result of evaluating PostfixExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>Let num1 be the result of Number(val)</li>
  <li>Let num2 be the result of evaluating the expression num1 - 1</li>
  <li>Call writeReference(ref,num2)</li>
  <li>Return num1</li>
</ul>
<h1>14.11 New expressions</h1>
<p>A new expression results in the invocation of the intrinsic construct method of the value computed by the expression that follows the new keyword. Arguments, if specified, are passed to the construct method. If no arguments are specified, the parentheses may be omitted.</p>
<h4>
<a name="wp129276"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FullNewExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>new</code></strong> FullNewSubexpression Arguments</p>
    </td>
  </tr>
</table>
<p>A <i>FullNewExpression</i> may be used as a <i>FullPostfixExpression</i>, or as a <i>FullNewSubexpression</i>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FullNewSubexpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>PrimaryExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>FullNewExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>FullNewSubexpression PropertyOperator</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>SuperExpression PropertyOperator</p>
    </td>
  </tr>
</table>
<p>A FullNewSubexpression may be used between the new keyword and the Arguments in a FullNewExpression, before a PropertyOperator in another FullNewSubexpression, or as a ShortNewSubexpression.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ShortNewExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>new</code></strong> ShortNewSubexpression</p>
    </td>
  </tr>
</table>
<p>A ShortNewExpression may be used as a PostfixExpression, or as a ShortNewSubexpression (that is, after the new keyword in another ShortNewExpression.)</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ShortNewSubexpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>FullNewSubexpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ShortNewExpression</p>
    </td>
  </tr>
</table>
<p>A <i>ShortNewSubexpression</i> may be used after the <code>new</code> keyword in a <i>ShortNewExpression</i>.</p>
<h4>
<a name="wp129350"></a>Verification</h4>
<p>FullNewExpression : new FullNewSubexpression Arguments</p>
<ul>
<li>Let fun be the result of verifying FullNewSubexpression</li>
  <li>Let args be the result of evaluating Arguments</li>
  <li>If isStrict()    <ul>
<li>Call verifyType(fun,Function)</li>
      <li>Let types be the value fun.types</li>
      <li>If args.length is not equal to types.length, throw a VerifyError exception</li>
      <li>For each type in args, call verifyType(args[i],types[i])</li>
    </ul>
</li>
  <li>Return the result of calling resultType(fun,new)</li>
</ul>
<p>FullNewSubexpression : PrimaryExpression</p>
<p>FullNewSubexpression : FullNewExpression</p>
<ul>
<li>Return the result of verifying the non-terminal symbol on the right-hand side of the production</li>
</ul>
<p>FullNewSubexpression : FullNewSubexpression PropertyOperator</p>
<ul>
<li>Let base be the result of verifying FullNewSubexpression</li>
  <li>Let name be the result of evaluating PropertyOperator</li>
  <li>Return the result of calling propertyType(base,name,null,false)</li>
</ul>
<p>FullNewSubexpression : SuperExpression PropertyOperator</p>
<ul>
<li>Let limited be the result of evaluating SuperExpression</li>
  <li>Let name be the result of evaluating PropertyOperator</li>
  <li>Return the result of calling propertyType (limited.this,name,limited.type,false)</li>
</ul>
<p>ShortNewExpression : new ShortNewSubexpression</p>
<ul>
<li>Let ref be the result of verifying ShortNewSubexpression</li>
  <li>Re turn the result of calling resultType(fun,new)</li>
</ul>
<p>ShortNewSubexpression : FullNewSubexpression</p>
<p>ShortNewSubexpression : ShortNewExpression</p>
<ul>
<li>Return the result of verifying the non-terminal symbol on the right-hand side of the production</li>
</ul>
<h4>
<a name="wp144783"></a>Evaluation</h4>
<p>FullNewExpression : new FullNewSubexpression Arguments</p>
<ul>
<li>Let ref be the result of evaluating FullNewSubexpression</li>
  <li>Let args be the result of evaluating Arguments</li>
  <li>Return the result of constructReference(ref,args)</li>
</ul>
<p>FullNewSubexpression : PrimaryExpression</p>
<ul>
<li>Return the result of evaluating PrimaryExpression</li>
</ul>
<p>FullNewSubexpression : FullNewExpression</p>
<ul>
<li>Return the result of evaluating FullNewExpression</li>
</ul>
<p>FullNewSubexpression : FullNewSubexpression PropertyOperator</p>
<ul>
<li>Let ref be the result of evaluating FullNewSubexpression</li>
  <li>Let base be the result of readReference(ref)</li>
  <li>Let name be the result of evaluating PropertyOperator</li>
  <li>Return the new instance Reference(base,name,null,false)</li>
</ul>
<p>FullNewSubexpression : SuperExpression PropertyOperator</p>
<ul>
<li>Let limited be the result of evaluating SuperExpression</li>
  <li>Return the new instance Reference(limited.this,name,limited.type)</li>
</ul>
<p>ShortNewExpression : new ShortNewSubexpression</p>
<ul>
<li>Let ref be the result of evaluating ShortNewSubexpression</li>
  <li>Return the result of constructReference(ref,null)</li>
</ul>
<p>ShortNewSubexpression : FullNewSubexpression</p>
<ul>
<li>Return the result of evaluating FullNewSubexpression</li>
</ul>
<p>ShortNewSubexpression : ShortNewExpression</p>
<ul>
<li>Return the result of evaluating ShortNewExpression</li>
</ul>
<h1>14.12 Property accessors</h1>
<h4>
<a name="wp129433"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>PropertyOperator</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>.  QualifiedIdentifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Brackets</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Brackets</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>[  ListExpression<sup>allowIn</sup>  ]</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp129463"></a>Verification</h4>
<p>PropertyOperator : .  QualifiedIdentifier</p>
<ul>
<li>Return the result of verifying QualifiedIdentifier</li>
</ul>
<p>PropertyOperator : Brackets</p>
<ul>
<li>Return the result of verifying Brackets</li>
</ul>
<p>Brackets : [  ListExpression  ]</p>
<ul>
<li>Verify ListExpression</li>
  <li>Return the type Name</li>
</ul>
<h4>
<a name="wp129478"></a>Evaluation</h4>
<p>PropertyOperator : . QualifiedIdentifier</p>
<ul>
<li>Return the result of evaluating QualifiedIdentifier</li>
</ul>
<p>PropertyOperator : Brackets</p>
<ul>
<li>Return the result of evaluating Brackets</li>
</ul>
<p>Brackets : [ ListExpression ]</p>
<ul>
<li>Let val be the result of evaluating ListExpression</li>
  <li>If val is of type Name    <ul>
<li>Let name be the set of names consisting of val</li>
    </ul>
</li>
  <li>Else    <ul>
<li>Let str be the result of calling String(val)</li>
      <li>Let namespaces be the result of calling openNamespaces(ctx)</li>
      <li>Let name be the value of makeMultiname(namespaces,str)</li>
    </ul>
</li>
  <li>Return name</li>
</ul>
<h1>14.13 Query operators</h1>
<h4>
<a name="wp129501"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>QueryOperator</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>..  QualifiedIdentifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>. ( ListExpression<sup>allowIn</sup> )</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp129519"></a>Verification</h4>
<p>QueryOperator : ..  QualifiedIdentifier</p>
<ul>
<li>Let type be a named argument to this verifier</li>
  <li>Call verifyType(type,XML)</li>
  <li>Verify QualifiedIdentifier</li>
  <li>Return type XMLList</li>
</ul>
<p>QueryOperator: .  (  ListExpression  )</p>
<ul>
<li>Let type be a named argument to this verifier</li>
  <li>Call verifyType(type,XML)</li>
  <li>Verify ListExpression</li>
  <li>Return type XMLList</li>
</ul>
<h4>
<a name="wp129535"></a>Evaluation</h4>
<p><i>QueryOperator</i> expressions are evaluated as described in the E4X specification.</p>



  <h1>14.14 Call expressions</h1>
<h4>
<a name="wp129541"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Arguments</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>( )</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>( ListExpression<sup>allowIn</sup>  )</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ArgumentList<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ArgumentList<sup>β</sup> , AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp129576"></a>Verification</h4>
<p>Arguments : ()</p>
<ul>
<li>Return an empty array of types</li>
</ul>
<p>Arguments : (  ArgumentList  )</p>
<ul>
<li>Let argTypes be an empty array of types</li>
  <li>Verify ArgumentList passing the argument argTypes</li>
  <li>Return argTypes</li>
</ul>
<p>ArgumentList : AssignmentExpression</p>
<ul>
<li>Let argTypes be a named argument to this verifier</li>
  <li>Let type be the result of verifying AssignmentExpression</li>
  <li>Call push(argTypes ,type)</li>
</ul>
<p>ArgumentList : ArgumentList  ,  AssignmentExpression</p>
<ul>
<li>Let args be the result of evaluating ArgumentList with argument argTypes</li>
  <li>Let type be the result of evaluating AssignmentExpression</li>
  <li>Call push(argTypes ,type)</li>
</ul>
<h4>
<a name="wp129600"></a>Evaluation</h4>
<p>Arguments : ()</p>
<ul>
<li>Return an empty Array</li>
</ul>
<p>Arguments : (  ArgumentList  )</p>
<ul>
<li>Let args be an empty Array</li>
  <li>Evaluate ArgumentList passing the argument args</li>
</ul>
<p>ArgumentList : AssignmentExpression</p>
<ul>
<li>Let val be the result of evaluating AssignmentExpression</li>
  <li>Call push(args,val)</li>
  <li>Return</li>
</ul>
<p>ArgumentList : ArgumentList  ,  AssignmentExpression</p>
<ul>
<li>Evaluate ArgumentList passing the argument args</li>
  <li>Let val be the result of evaluating AssignmentExpression</li>
  <li>Call push(args,val)</li>
  <li>Return</li>
</ul>
<h1>14.15 Unary expressions</h1>
<h4>
<a name="wp129626"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>UnaryExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>PostfixExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>delete</code></strong>  PostfixExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>void</code></strong>  UnaryExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>typeof</code></strong>  UnaryExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>++</code></strong>   PostfixExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>--</code></strong>  PostfixExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>+</code></strong>  UnaryExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>-</code></strong>  UnaryExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>-</code></strong>  NegatedMinLong</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>~</code></strong>  UnaryExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>!</code></strong>  UnaryExpression</p>
    </td>
  </tr>
</table>
<p>A UnaryExpression may be used where ever a MultiplicativeExpression may be used and in another UnaryExpression after the <code>void</code> or <code>typeof</code> keywords or after the <code>+</code>, <code>-</code>, <code>~</code>, and <code>!</code> punctuators.</p>
<h4>
<a name="wp129682"></a>Verification</h4>
<p>UnaryExpression : PostfixExpression</p>
<ul>
<li>Return the result of verifying PostfixExpression</li>
</ul>
<p>UnaryExpression : delete  PostfixExpression</p>
<ul>
<li>Verify PostfixExpression</li>
  <li>Return the type Boolean</li>
</ul>
<p>UnaryExpression : void  UnaryExpression</p>
<ul>
<li>Verify UnaryExpression</li>
  <li>Return the type void</li>
</ul>
<p>UnaryExpression : typeof  UnaryExpression</p>
<ul>
<li>Verify UnaryExpression</li>
  <li>Return the type String</li>
</ul>
<p>UnaryExpression : ++  PostfixExpression</p>
<p>UnaryExpression : --  PostfixExpression</p>
<p>UnaryExpression : +  PostfixExpression</p>
<p>UnaryExpression : -  PostfixExpression</p>
<ul>
<li>Let type be the result of verifying PostfixExpression</li>
  <li>Call verifyType(type,int)</li>
  <li>Return the type Number</li>
</ul>
<p>UnaryExpression : -  NegatedMinLong</p>
<ul>
<li>Return the type Number</li>
</ul>
<p>UnaryExpression : ~  UnaryExpression</p>
<ul>
<li>Let type be the result of verifying UnaryExpression</li>
  <li>Call verifyType(type,int)</li>
  <li>Return the type int</li>
</ul>
<p>UnaryExpression : !  UnaryExpression</p>
<ul>
<li>Let type be the result of verifying UnaryExpression</li>
  <li>Call verifyType(type,Boolean)</li>
  <li>Return the type Boolean</li>
</ul>
<h4>
<a name="wp129728"></a>Evaluation</h4>
<p>UnaryExpression : PostfixExpression</p>
<ul>
<li>Return the result of evaluating PostfixExpression</li>
</ul>
<p>UnaryExpression : delete  PostfixExpression</p>
<ul>
<li>Let ref be the result of evaluating PostfixExpression</li>
  <li>If ref is of type Reference    <ul>
<li>Return the result of calling deleteReference(ref)</li>
    </ul>
</li>
  <li>Else    <ul>
<li>Return true</li>
    </ul>
</li>
</ul>
<p>UnaryExpression : void  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating UnaryExpression</li>
  <li>Call readReference(ref)</li>
  <li>Return undefined</li>
</ul>
<p>UnaryExpression : typeof  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating UnaryExpression</li>
  <li>If ref is a Reference and ref.base is null    <ul>
<li>Let val be the value undefined</li>
    </ul>
</li>
  <li>Else    <ul>
<li>Let val be the result of readReference(ref)</li>
    </ul>
</li>
  <li>Return the result of typeOfString(val)</li>
</ul>
<p>UnaryExpression : ++  PostfixExpression</p>
<ul>
<li>Let ref be the result of evaluating PostfixExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>Let num1 be the result of Number(val)</li>
  <li>Let num2 be the result of calling add(num1,1)</li>
  <li>Call writeReference(ref,num2)</li>
  <li>Return num2</li>
</ul>
<p>UnaryExpression : --  PostfixExpression</p>
<ul>
<li>Let ref be the result of evaluating PostfixExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>Let num1 be the result of Number(val)</li>
  <li>Let num2 be the result of evaluating the expression subtract(num1,1)</li>
  <li>Call writeReference(ref,num2)</li>
  <li>Return num2</li>
</ul>
<p>UnaryExpression : +  PostfixExpression</p>
<ul>
<li>Let ref be the result of evaluating PostfixExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>Return the result of calling Number(val)</li>
</ul>
<p>UnaryExpression : -  PostfixExpression</p>
<ul>
<li>Let ref be the result of evaluating PostfixExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>Let num be the result of Number(val)</li>
  <li>If num == NaN, then return NaN</li>
  <li>Return the result of the expression multiply(-1,num)</li>
</ul>
<p>UnaryExpression : -  NegatedMinLong</p>
<ul>
<li>Return the Number value -2E63</li>
</ul>
<p>UnaryExpression : ~  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating UnaryExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>Let int32 be the result of int(val)</li>
  <li>Return the result of bitwiseNot(int32)</li>
</ul>
<p>UnaryExpression : !  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating UnaryExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>Let bool be the result of Boolean(val)</li>
  <li>If bool == true    <ul>
<li>Return false</li>
    </ul>
</li>
  <li>Return true</li>
</ul>
<h1>14.16 Binary expressions</h1>
<p>The binary expressions are left associative and have relative precedence as specified in the grammar:  <i>LogicalOrExpression</i> has the lowest precedence and <i>MultiplicativeExpression</i> has the highest precedence.</p>



  <h1>14.16.1 Multiplicative expressions</h1>
<h4>
<a name="wp129815"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>MultiplicativeExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>UnaryExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>MultiplicativeExpression  <strong>*</strong>  UnaryExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>MultiplicativeExpression  <strong>/</strong>  UnaryExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>MultiplicativeExpression  <strong>%</strong>  UnaryExpression</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp129841"></a>Verification</h4>
<p>MultiplicativeExpression : UnaryExpression</p>
<ul>
<li>Return the result of verifying UnaryExpression</li>
</ul>
<p>MultiplicativeExpression : MultiplicativeExpression  *  UnaryExpression</p>
<p>MultiplicativeExpression: MultiplicativeExpression  /  UnaryExpression</p>
<p>MultiplicativeExpression: MultiplicativeExpression  %  UnaryExpression</p>
<ul>
<li>Let x be the result of evaluating MultiplicativeExpression</li>
  <li>Call verifyType(x,Number)</li>
  <li>Let y be the result of evaluating UnaryExpression</li>
  <li>Call verifyType(y,Number)</li>
  <li>Return type Number</li>
</ul>
<h4>
<a name="wp129857"></a>Evaluation</h4>
<p>MultiplicativeExpression : UnaryExpression</p>
<ul>
<li>Return the result of evaluating UnaryExpression</li>
</ul>
<p>MultiplicativeExpression : MultiplicativeExpression  *  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating MultiplicativeExpression</li>
  <li>Let x be the result of calling readReference(ref)</li>
  <li>Let ref be the result of evaluating UnaryExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of calling multiply(x,y)</li>
</ul>
<p>MultiplicativeExpression: MultiplicativeExpression  /  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating MultiplicativeExpression</li>
  <li>Let x be the result of calling readReference(ref)</li>
  <li>Let ref be the result of evaluating UnaryExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of calling divide(x,y)</li>
</ul>
<p>MultiplicativeExpression: MultiplicativeExpression  %  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating MultiplicativeExpression</li>
  <li>Let x be the result of calling readReference(ref)</li>
  <li>Let ref be the result of evaluating UnaryExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of calling remainder(x,y)</li>
</ul>
<h1>14.16.2 Additive expressions</h1>
<h4>
<a name="wp129889"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>AdditiveExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>MultiplicativeExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>AdditiveExpression <strong>+</strong> MultiplicativeExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>AdditiveExpression <strong>-</strong> MultiplicativeExpression</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp129911"></a>Verification</h4>
<p>AdditiveExpression: MultiplicativeExpression</p>
<ul>
<li>Return the result of evaluating MultiplicativeExpression</li>
</ul>
<p>AdditiveExpression: MultiplicativeExpression  +  UnaryExpression</p>
<ul>
<li>Let x be the result of verifying MultiplicativeExpression</li>
  <li>Let y be the result of verifying UnaryExpression</li>
  <li>Return type *</li>
</ul>
<p>AdditiveExpression: MultiplicativeExpression  -  UnaryExpression</p>
<ul>
<li>Let x be the result of verifying MultiplicativeExpression</li>
  <li>Call verifyType(x,Number)</li>
  <li>Let y be the result of verifying UnaryExpression</li>
  <li>Call verifyType(y,Number)</li>
  <li>Return type Number</li>
</ul>
<h4>
<a name="wp145402"></a>Evaluation</h4>
<p>AdditiveExpression: MultiplicativeExpression</p>
<ul>
<li>Return the result of evaluating MultiplicativeExpression</li>
</ul>
<p>AdditiveExpression: MultiplicativeExpression  +  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating MultiplicativeExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating UnaryExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of plus(x,y)</li>
</ul>
<p>AdditiveExpression: MultiplicativeExpression  -  UnaryExpression</p>
<ul>
<li>Let ref be the result of evaluating MultiplicativeExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating UnaryExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of minus(x,y)</li>
</ul>
<h1>14.16.3 Shift expressions</h1>
<h4>
<a name="wp129955"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ShiftExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>AdditiveExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ShiftExpression <strong>&lt;&lt;</strong> AdditiveExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ShiftExpression <strong>&gt;&gt;</strong> AdditiveExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ShiftExpression <strong>&gt;&gt;&gt;</strong> AdditiveExpression</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp129981"></a>Verification</h4>
<p>ShiftExpression : AdditiveExpression</p>
<ul>
<li>Return the result of verifying AdditiveExpression</li>
</ul>
<p>ShiftExpression : ShiftExpression &lt;&lt; AdditiveExpression</p>
<p>ShiftExpression : ShiftExpression &gt;&gt; AdditiveExpression</p>
<p>ShiftExpression : ShiftExpression &gt;&gt;&gt; AdditiveExpression</p>
<ul>
<li>Let x be the result of verifying ShiftExpression</li>
  <li>Call verifyType(x,Number)</li>
  <li>Let y be the result of verifying AdditiveExpression</li>
  <li>Call verifyType(y,Number)</li>
  <li>Return the type Number</li>
</ul>
<h4>
<a name="wp129997"></a>Evaluation</h4>
<p>ShiftExpression : AdditiveExpression</p>
<ul>
<li>Return the result of evaluating AdditiveExpression</li>
</ul>
<p>ShiftExpression : ShiftExpression &lt;&lt; AdditiveExpression</p>
<ul>
<li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating AdditiveExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of shiftLeft(x,y)</li>
</ul>
<p>ShiftExpression : ShiftExpression &gt;&gt; AdditiveExpression</p>
<ul>
<li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating AdditiveExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of shiftRight(x,y)</li>
</ul>
<p>ShiftExpression : ShiftExpression &gt;&gt;&gt; AdditiveExpression</p>
<ul>
<li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating AdditiveExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of shiftRightUnsigned(x,y)</li>
</ul>
<h1>14.16.4 Relational expressions</h1>
<h4>
<a name="wp130029"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>RelationalExpression<sup>allowIn</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ShiftExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>allowIn</sup><strong><code>&lt;</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>allowIn</sup><strong><code>&gt;</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>allowIn</sup><strong><code>&lt;=</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>allowIn</sup><strong><code>&gt;=</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>allowIn</sup><strong><code>in</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>allowIn</sup><strong><code>instanceof</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>allowIn</sup><strong><code>is</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>allowIn</sup><strong><code>as</code></strong> ShiftExpression</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>RelationalExpression<sup>noIn</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ShiftExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>noIn</sup><strong><code>&lt;</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>noIn</sup><strong><code>&gt;</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>noIn</sup><strong><code>&lt;=</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>noIn</sup><strong><code>&gt;=</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>noIn</sup><strong><code>instanceof</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>noIn</sup><strong><code>is</code></strong> ShiftExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>noIn</sup><strong><code>as</code></strong> ShiftExpression</p>
    </td>
  </tr>
</table>
<p>The <code>noIn</code> version of <code>RelationalExpression</code> exists to avoid ambiguity between the <code>in</code> operator in a relational expression and the <code>in</code> operator in a <code>for</code> statement.  </p>
<h4>
<a name="wp130115"></a>Verification</h4>
<p>RelationalExpression : ShiftExpression</p>
<ul>
<li>Return the result of verifying ShiftExpression</li>
</ul>
<p>RelationalExpression : RelationalExpression &lt; ShiftExpression</p>
<p>RelationalExpression : RelationalExpression &gt; ShiftExpression</p>
<p>RelationalExpression : RelationalExpression &lt;= ShiftExpression</p>
<p>RelationalExpression : RelationalExpression &gt;= ShiftExpression</p>
<p>RelationalExpression : RelationalExpression in ShiftExpression</p>
<p>RelationalExpression : RelationalExpression instanceof ShiftExpression</p>
<ul>
<li>Let x be the result of verifying RelationalExpression</li>
  <li>Let y be the result of verifying ShiftExpression</li>
  <li>Return the type Boolean</li>
</ul>
<p>RelationalExpression : RelationalExpression  is  ShiftExpression</p>
<ul>
<li>Verify RelationalExpression</li>
  <li>Let type be the result of verifying ShiftExpression</li>
  <li>Call verifyType(type,Type)</li>
  <li>Return the type Boolean</li>
</ul>
<p>RelationalExpression : RelationalExpression  as  ShiftExpression</p>
<ul>
<li>Verify RelationalExpression</li>
  <li>Let type be the result of verifying ShiftExpression</li>
  <li>Call verifyType(type,Type)</li>
  <li>Return the type</li>
</ul>
<h4>
<a name="wp130146"></a>Evaluation</h4>
<p>RelationalExpression : ShiftExpression</p>
<ul>
<li>Return the result of evaluating ShiftExpression</li>
</ul>
<p>RelationalExpression : RelationalExpression &lt; ShiftExpression</p>
<ul>
<li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of lessThan(x,y)</li>
</ul>
<p>RelationalExpression : RelationalExpression &gt; ShiftExpression</p>
<ul>
<li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of lessThan(y,x)</li>
</ul>
<p>RelationalExpression : RelationalExpression &lt;= ShiftExpression</p>
<ul>
<li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of lessThanOrEquals(x,y)</li>
</ul>
<p>RelationalExpression : RelationalExpression &gt;= ShiftExpression</p>
<ul>
<li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of lessThanOrEquals(y,x)</li>
</ul>
<p>RelationalExpression : RelationalExpression in ShiftExpression</p>
<ul>
<li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of hasProperty(x,y)</li>
</ul>
<p>RelationalExpression : RelationalExpression instanceof ShiftExpression</p>
<ul>
<li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of instanceof(x,y)</li>
</ul>
<p>RelationalExpression : RelationalExpression  is  ShiftExpression</p>
<ul>
<li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of isType(x,y)</li>
</ul>
<p>RelationalExpression : RelationalExpression  as  ShiftExpression</p>
<ul>
<li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating ShiftExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of asType(x,y)</li>
</ul>
<h1>14.16.5 Equality expressions</h1>
<h4>
<a name="wp130218"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>EqualityExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RelationalExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>EqualityExpression<sup>β</sup><strong><code>==</code></strong> RelationalExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>EqualityExpression<sup>β</sup><strong><code>!=</code></strong> RelationalExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>EqualityExpression<sup>β</sup><strong><code>===</code></strong> RelationalExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>EqualityExpression<sup>β</sup><strong><code>!==</code></strong> RelationalExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<p>The β notation signifies that  both the <code>allowIn</code> and <code>noIn</code> variants are included.</p>

<h4>
<a name="wp130248"></a>Verification</h4>
<p>EqualityExpression : RelationalExpression</p>
<ul>
<li>Return the result of verifying RelationalExpression</li>
</ul>
<p>EqualityExpression : EqualityExpression == RelationalExpression</p>
<p>EqualityExpression : EqualityExpression != RelationalExpression</p>
<p>EqualityExpression : EqualityExpression === RelationalExpression</p>
<p>EqualityExpression : EqualityExpression !== RelationalExpression</p>
<ul>
<li>Let x be the result of verifying EqualityExpression</li>
  <li>Let y be the result of verifying RelationalExpression</li>
  <li>If isStrict() and x is not a subtype of y and y is not a subtype of x</li>
  <li>If x is final or y is not an interface, then throw a type error</li>
  <li>If y is final or x is not an interface, then throw a type error</li>
  <li>Return type Boolean</li>
</ul>
<h4>
<a name="wp130266"></a>Evaluation</h4>
<p>EqualityExpression : RelationalExpression</p>
<ul>
<li>Return the result of evaluating RelationalExpression</li>
</ul>
<p>EqualityExpression : EqualityExpression == RelationalExpression</p>
<ul>
<li>Let ref be the result of evaluating EqualityExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of equals(x,y)</li>
</ul>
<p>EqualityExpression : EqualityExpression != RelationalExpression</p>
<ul>
<li>Let ref be the result of evaluating EqualityExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of not equals(x,y)</li>
</ul>
<p>EqualityExpression : EqualityExpression === RelationalExpression</p>
<ul>
<li>Let ref be the result of evaluating EqualityExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of strictEquals(x,y)</li>
</ul>
<p>EqualityExpression : EqualityExpression !== RelationalExpression</p>
<ul>
<li>Let ref be the result of evaluating EqualityExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating RelationalExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of not strictEquals(x,y)</li>
</ul>
<h1>14.16.6 Bitwise expressions</h1>
<h4>
<a name="wp130306"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>BitwiseAndExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>EqualityExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>BitwiseAndExpression<sup>β</sup><strong><code>&amp;</code></strong> EqualityExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>BitwiseXorExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>BitwiseAndExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>BitwiseXorExpression<sup>β</sup><strong><code>^</code></strong> BitwiseAndExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>BitwiseOrExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>BitwiseXorExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>BitwiseOrExpression<sup>β</sup><strong><code>|</code></strong> BitwiseXorExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp130356"></a>Verification</h4>
<p>BitwiseAndExpression : EqualityExpression</p>
<ul>
<li>Return the result of verifying EqualityExpression</li>
</ul>
<p>BitwiseAndExpression : BitwiseAndExpression &amp; EqualityExpression</p>
<ul>
<li>Let x be the result of evaluating BitwiseAndExpression</li>
  <li>Call verifyType(x,Number)</li>
  <li>Let y be the result of evaluating EqualityExpression</li>
  <li>Call verifyType(y,Number)</li>
  <li>Return the type Number</li>
</ul>
<p>BitwiseXorExpression : BitwiseAndExpression</p>
<ul>
<li>Return the result of evaluating BitwiseAndExpression</li>
</ul>
<p>BitwiseXorExpression : BitwiseXorExpression ^ BitwiseAndExpression</p>
<ul>
<li>Let x be the result of evaluating BitwiseXorExpression</li>
  <li>Call verifyType(x,Number)</li>
  <li>Let y be the result of evaluating BitwiseAndExpression</li>
  <li>Call verifyType(y,Number)</li>
  <li>Return the type Number</li>
</ul>
<p>BitwiseOrExpression : BitwiseXorExpression</p>
<ul>
<li>Return the result of evaluating BitwiseXorExpression</li>
</ul>
<p>BitwiseOrExpression : BitwiseOrExpression | BitwiseXorExpression</p>
<ul>
<li>Let x be the result of evaluating BitwiseOrExpression</li>
  <li>Call verifyType(x,Number)</li>
  <li>Let y be the result of evaluating BitwiseXorExpression</li>
  <li>Call verifyType(y,Number)</li>
  <li>Return the type Number</li>
</ul>
<h4>
<a name="wp130394"></a>Evaluation</h4>
<p>BitwiseAndExpression : EqualityExpression</p>
<ul>
<li>Return the result of evaluating EqualityExpression</li>
</ul>
<p>BitwiseAndExpression : BitwiseAndExpression &amp; EqualityExpression</p>
<ul>
<li>Let ref be the result of evaluating BitwiseAndExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating EqualityExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of bitwiseAnd(x,y)</li>
</ul>
<p>BitwiseXorExpression : BitwiseAndExpression</p>
<ul>
<li>Return the result of evaluating BitwiseAndExpression</li>
</ul>
<p>BitwiseXorExpression : BitwiseXorExpression ^ BitwiseAndExpression</p>
<ul>
<li>Let ref be the result of evaluating BitwiseXorExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating BitwiseAndExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of bitwiseXor(x,y)</li>
</ul>
<p>BitwiseOrExpression : BitwiseXorExpression</p>
<ul>
<li>Return the result of evaluating BitwiseXorExpression</li>
</ul>
<p>BitwiseOrExpression : BitwiseOrExpression | BitwiseXorExpression</p>
<ul>
<li>Let ref be the result of evaluating BitwiseOrExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating BitwiseXorExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of bitwiseOr(x,y)</li>
</ul>
<h1>14.16.7 Logical expressions</h1>
<h4>
<a name="wp146843"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>LogicalAndExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>BitwiseOrExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>LogicalAndExpression<sup>β</sup><strong><code>&amp;&amp;</code></strong> BitwiseOrExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>LogicalOrExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>LogicalAndExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>LogicalOrExpression<sup>β</sup><strong><code>||</code></strong> LogicalXorExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp130484"></a>Verification</h4>
<p>LogicalAndExpression: BitwiseOrExpression</p>
<ul>
<li>Return the result of verifying BitwiseOrExpression</li>
</ul>
<p>LogicalAndExpression: LogicalAndExpression &amp;&amp; BitwiseOrExpression</p>
<ul>
<li>Let x be the result of evaluating LogicalAndExpression</li>
  <li>Let y be the result of evaluating BitwiseOrExpression</li>
  <li>Return the type *</li>
</ul>
<p>LogicalOrExpression : LogicalAndExpression</p>
<ul>
<li>Return the result of evaluating LogicalAndExpression</li>
</ul>
<p>LogicalOrExpression : LogicalOrExpression || LogicalOrExpression</p>
<ul>
<li>Let x be the result of evaluating LogicalOrExpression</li>
  <li>Let y be the result of evaluating LogicalOrExpression</li>
  <li>Return the type *</li>
</ul>
<h4>
<a name="wp130516"></a>Evaluation</h4>
<p>LogicalAndExpression: BitwiseOrExpression</p>
<ul>
<li>Return the result of evaluating BitwiseOrExpression</li>
</ul>
<p>LogicalAndExpression: LogicalAndExpression &amp;&amp; BitwiseOrExpression</p>
<ul>
<li>Let ref be the result of evaluating LogicalAndExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating BitwiseOrExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of logicalAnd(x,y)</li>
</ul>
<p>LogicalOrExpression : LogicalAndExpression</p>
<ul>
<li>Return the result of evaluating LogicalAndExpression</li>
</ul>
<p>LogicalOrExpression : LogicalOrExpression || LogicalOrExpression</p>
<ul>
<li>Let ref be the result of evaluating LogicalOrExpression</li>
  <li>Let x be the result of readReference(ref)</li>
  <li>Let ref be the result of evaluating LogicalOrExpression</li>
  <li>Let y be the result of readReference(ref)</li>
  <li>Return the result of logicalOr(x,y)</li>
</ul>
<h1>14.17 Conditional expressions</h1>
<h4>
<a name="wp146848"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ConditionalExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>LogicalOrExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>LogicalOrExpression<sup>β</sup><strong>?</strong>  AssignmentExpression<sup>β</sup><strong>:</strong>  AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<p>A <i>ConditionalExpression</i> may be used where ever an <i>AssignmentExpression</i> may be used.</p>
<div class="listing">
<pre>
y = true ? x = true : x = false
</pre>
</div>
<h4>
<a name="wp130578"></a>Verification</h4>
<p>ConditionalExpression : LogicalOrExpression</p>
<ul>
<li>Return the result of verifying LogicalOrExpression</li>
</ul>
<p>ConditionalExpression : LogicalOrExpression  ?  AssignmentExpression  :  AssignmentExpression</p>
<ul>
<li>Verify all non-terminal symbols on the right-hand side of the production</li>
  <li>Return type *</li>
</ul>
<h4>
<a name="wp130589"></a>Evaluation</h4>
<p>ConditionalExpression : LogicalOrExpression</p>
<ul>
<li>Return the result of evaluating LogicalOrExpression</li>
</ul>
<p>ConditionalExpression : LogicalOrExpression  ?  AssignmentExpression  :  AssignmentExpression</p>
<ul>
<li>Let ref be the result of evaluating LogicalOrExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>If Boolean(val) is equal to true</li>
  <li>Return the result of evaluating the first AssignmentExpression</li>
  <li>Else</li>
  <li>Return the result of evaluating the second AssignmentExpression</li>
</ul>
<h1>14.18 Non-assignment expressions</h1>
<h4>
<a name="wp146853"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>NonAssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>LogicalOrExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>LogicalOrExpression<sup>β</sup><strong>?</strong> NonAssignmentExpression<sup>β</sup><strong>:</strong> NonAssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<p>A <i>NonAssignmentExpression</i> may be used where ever a <i>TypeExpression</i> may be used.</p>
<div class="listing">
<pre>
var x : hintString ? String : Number
</pre>
</div>
<h4>
<a name="wp130628"></a>Verification</h4>
<p>NonAssignmentExpression : LogicalOrExpression</p>
<ul>
<li>Return the result of verifying LogicalOrExpression</li>
</ul>
<p>ConditionalExpression : LogicalOrExpression  ?  AssignmentExpression  :  AssignmentExpression</p>
<ul>
<li>Verify all non-terminal symbols on the right-hand side of the production</li>
  <li>Return type *</li>
</ul>
<h4>
<a name="wp130639"></a>Evaluation</h4>
<p>NonAssignmentExpression : LogicalOrExpression</p>
<ul>
<li>Return the result of evaluating LogicalOrExpression</li>
</ul>
<p>NonAssignmentExpression : LogicalOrExpression  ?  AssignmentExpression  :  AssignmentExpression</p>
<ul>
<li>Let ref be the result of evaluating LogicalOrExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>If Boolean(val) is equal to true</li>
  <li>Return the result of evaluating the first AssignmentExpression</li>
  <li>Else</li>
  <li>Return the result of evaluating the second AssignmentExpression</li>
</ul>
<h1>14.19 Assignment expressions</h1>
<h4>
<a name="wp146858"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ConditionalExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>PostfixExpression <strong><code>=</code></strong> AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>PostfixExpression CompoundAssignment AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>PostfixExpression LogicalAssignment AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>CompoundAssignment</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>*=</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>/=</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>%=</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>+=</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>-=</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>&lt;&lt;=</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>&gt;&gt;=</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>&gt;&gt;&gt;=</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>&amp;=</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>^=</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>|=</code></strong></p>    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>LogicalAssignment</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>&amp;&amp;=</code></strong></p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>^^=</code></strong></p>    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>||=</code></strong></p>    </td>
  </tr>
</table>
<h4>
<a name="wp130754"></a>Verification</h4>
<p>AssignmentExpression : PostfixExpression = AssignmentExpression</p>
<p>AssignmentExpression : PostfixExpression CompoundAssignment AssignmentExpression</p>
<p>AssignmentExpression : PostfixExpression LogicalAssignment AssignmentExpression</p>
<ul>
<li>Let lhstype be the result of verifying PostfixExpression</li>
  <li>Let rhstype be the result of verifying AssignmentExpression</li>
  <li>Call verifyType(rhstype,lhstype)</li>
  <li>Return rhstype</li>
</ul>
<h4>
<a name="wp130765"></a>Evaluation</h4>
<p>AssignmentExpression : PostfixExpression = AssignmentExpression</p>
<ul>
<li>Let ref1 be the result of verifying PostfixExpression</li>
  <li>Let ref2 be the result of verifying AssignmentExpression</li>
  <li>Let val be the result of calling readReference(ref2)</li>
  <li>Call writeReference(ref1,val)</li>
  <li>Return val</li>
</ul>
<p>AssignmentExpression : PostfixExpression CompoundAssignment AssignmentExpression</p>
<p>AssignmentExpression : PostfixExpression LogicalAssignment AssignmentExpression</p>
<ul>
<li>Let ref1 be the result of verifying PostfixExpression</li>
  <li>Let ref2 be the result of verifying AssignmentExpression</li>
  <li>Let val1 be the result of calling readReference(ref1)</li>
  <li>Let val2 be the result of calling readReference(ref2)</li>
  <li>Let val be the result of calling the operator method that corresponds to CompoundAssignment or LogicalAssignment with arguments val1 and val2</li>
  <li>Call writeReference(ref1,val)</li>
  <li>Return val</li>
</ul>
<h1>14.20 List expressions</h1>
<h4>
<a name="wp146863"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ListExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ListExpression<sup>β</sup><strong>,</strong> AssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<p><i>ListExpression</i> may be used as an <i>ExpressionStatement</i>, after the <code>case</code> keyword in a <i>CaseLabel</i>, after the <code>in</code> keyword in a <i>ForInStatement</i>, as a <i>ForInitializer</i>, as an <i>OptionalExpression</i>, after the <code>return</code> keyword in a <i>ReturnStatement</i>, after the <code>throw</code> keyword in a <i>ThrowStatement</i>, in a <i>ParenthesizedListExpression</i>, in a <i>Brackets</i>, or in an <i>Arguments</i>. </p>
<h4>
<a name="wp130808"></a>Verification</h4>
<p>ListExpression : AssignmentExpression</p>
<ul>
<li>Return the result of verifying AssignmentExpression</li>
</ul>
<p>ListExpression : ListExpression  ,  AssignmentExpression</p>
<ul>
<li>Verify ListExpression</li>
  <li>Return the result of verifying AssignmentExpression</li>
</ul>
<h4>
<a name="wp130819"></a>Evaluation</h4>
<p>ListExpression : AssignmentExpression</p>
<ul>
<li>Let ref be the result of evaluating AssignmentExpression</li>
  <li>Return the result of readReference(ref)</li>
</ul>
<p>ListExpression : ListExpression  ,  AssignmentExpression</p>
<ul>
<li>Evaluate ListExpression</li>
  <li>Let ref be the result of evaluating AssignmentExpression</li>
  <li>Return the result of readReference(ref)</li>
</ul>
<h1>14.21 Type expressions</h1>
<h4>
<a name="wp146868"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>TypeExpression<sup>β</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>NonAssignmentExpression<sup>β</sup></p>
    </td>
  </tr>
</table>
<p><i>TypeExpression</i> is used in a typed identifier definition, result type definition, and extends and implements declarations of classes and interfaces.</p>
<div class="listing">
<pre>
var x : String
function f() : Number { return y }
class A extends B implements C, D {}
</pre>
</div>
<h4>
<a name="wp155586"></a>Verification</h4>
<p>TypeExpression : AssignmentExpression</p>
<ul>
<li>If AssignmentExpression consists of the identifier *</li>
  <li>Return type *</li>
  <li>Return the result of verifying AssignmentExpression</li>
</ul>
<h4>
<a name="wp130862"></a>Evaluation</h4>
<p>TypeExpression : AssignmentExpression</p>
<ul>
<li>Let ref be the result of evaluating AssignmentExpression</li>
  <li>Let val be the result of readReference(ref)</li>
  <li>If isType(val,Type) equals false</li>
  <li>Throw TypeError</li>
  <li>Return val</li>
</ul>
<h1>15 Statements</h1>
<table border="0" cellpadding="0" cellspacing="0"><tr bgcolor="#F8F8F8">
<td>
      <p>ω =  {abbrev, noShortIf, full}</p>
    </td>
  </tr></table>
<h4>
<a name="wp146873"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Statement<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>SuperStatement Semicolon<sup>ω</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Block</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>IfStatement<sup>ω</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>SwitchStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>DoStatement Semicolon<sup>ω</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>WhileStatement<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ForStatementw<sup>ω</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>WithStatement<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ContinueStatement Semicolon<sup>ω</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>BreakStatement Semicolon<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ReturnStatement Semicolon<sup>ω</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ThrowStatement Semicolon<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>TryStatement</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ExpressionStatement Semicolon<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>LabeledStatement<sup>ω</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>DefaultXMLNamespaceStatement</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Substatement<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>EmptyStatement</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Statement<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>SimpleVariableDefinition Semicolon<sup>ω</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Substatements</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>SubstatementsPrefix Substatement<sup>abbrev</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>SubstatementsPrefix</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>SubstatementsPrefix Substatement<sup>full</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Semicolon<sup>abbrev</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>;</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>VirtualSemicolon</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Semicolon<sup>noShortIf</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>;</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>VirtualSemicolon</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Semicolon<sup>full</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>;</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>VirtualSemicolon</p>
    </td>
  </tr>
</table>
<h1>15.1 Empty statement</h1>
<h4>
<a name="wp146878"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>EmptyStatement </p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>;</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131081"></a>Verification</h4>
<p>EmptyStatment : ;</p>
<ul>
<li>Do nothing</li>
</ul>
<h4>
<a name="wp131087"></a>Evaluation</h4>
<ul>
<li>Return the value of named argument cv</li>
</ul>
<h1>15.2 Expression statement</h1>
<h4>
<a name="wp146883"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ExpressionStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>[lookahead !{ <strong><code>function</code></strong>, { }] ListExpression<sup>allowIn</sup></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131108"></a>Verification</h4>
<p>ExpressionStatement : ListExpression</p>
<ul>
<li>Verify ListExpression</li>
</ul>
<h4>
<a name="wp131114"></a>Evaluation</h4>
<p>ExpressionStatement : ListExpression</p>
<ul>
<li>Let ref be the result of evaluating ListExpression</li>
  <li>Return the result of readReference(ref)</li>
</ul>
<h1>15.3 Super statement</h1>
<p>A <i>SuperStatement</i> causes the constructor of the immediate base class to be called. If no <i>SuperStatement</i> is specified, the default constructor of the base class is called. Unlike in Java, a <i>SuperStatement</i> may be used anywhere in the body of the constructor before an instance property is accessed. It is a compile error to use more than one <i>SuperStatement</i> in a constructor.</p>
<h4>
<a name="wp146888"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>SuperStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>super</code></strong> Arguments</p>
    </td>
  </tr>
</table>
<p>A <i>SuperStatement</i> may only be used inside a constructor. It is a syntax error to use a <i>SuperStatement</i> anywhere else in a program.</p>
<div class="listing">
<pre>
class B extends A {
    function B(x,y,z) {
        super(x,y)
        // other constructor code here
    }
}
</pre>
</div>
<h4>
<a name="wp131148"></a>Semantics</h4>
<h4>
<a name="wp131150"></a>Compatibility</h4>
<p>In ActionScript 2.0, a <i>SuperStatement</i> may be used anywhere in a program, except in a static method of a class. It is equivalent to the following statement:</p>
<div class="listing">
<pre>
this.constructor.prototype.constructor.apply(this,arguments)
</pre>
</div>
<p>If used in a class instance function, it will call the class's constructor function using the current value of <code>this</code> as the first argument. If used in global code, it will call the global object's class's super constructor.</p>
<p>In ActionScript 3.0, a <i>SuperStatement</i> may only be used in an instance constructor. All other uses will result in a syntax error. Also, if the number and types of <i>Arguments</i> is not compatible with <i>Parameters</i> of the super constructor, the result is a runtime error.</p>



  <h1>15.4 Block statement</h1>
<h4>
<a name="wp146895"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Block</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>{ Directives }</p>
    </td>
  </tr>
</table>
<h1>15.5 Labeled statement</h1>
<h4>
<a name="wp146900"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>LabeledStatement<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier : Substatement<sup>ω</sup></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131194"></a>Verification</h4>
<p>LabeledStatement : Substatement</p>
<ul>
<li>Let breakTargets be the current set of possible targets of BreakStatements</li>
  <li>Let target be the sequence of characters of Identifier</li>
  <li>If target is a member of breakTargets, throw a SyntaxError</li>
  <li>Add target to breakTargets by calling breakTargets.push(target)</li>
  <li>Verify Substatement</li>
</ul>
<h4>
<a name="wp131204"></a>Evaluation</h4>
<p>LabeledStatement : Substatement</p>
<ul>
<li>Try</li>
  <li>Return the result of evaluating Substatement</li>
  <li>Catch exception x if x is of type Break</li>
  <li>Let label be a string value consisting of the same sequence of characters as Identifier</li>
  <li>If x.target equals label, then return x.value</li>
  <li>Throw x</li>
</ul>
<h4>
<a name="wp131215"></a>Compatibility</h4>
<p>ActionScript 2.0 does not allow <i>LabeledStatements</i>. This is a compatible change to the language.</p>



  <h1>15.6 Conditional statements</h1>



  <h1>15.6.1 If statement</h1>
<h4>
<a name="wp146906"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1"><p>IfStatement<sup>abbrev</sup></p></td>
  </tr>
<tr>
<td><p> </p></td>
    <td><p><strong><code>if</code></strong> ParenListExpression Substatement<sup>abbrev</sup></p></td>
  </tr>
<tr bgcolor="#F8F8F8">
<td><p> </p></td>
    <td><p><strong><code>if</code></strong> ParenListExpression Substatement<sup>noShortIf</sup><strong><code>else</code></strong> Substatement<sup>abbrev</sup></p></td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>IfStatement<sup>full</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>if</code></strong> ParenListExpression Substatement<sup>full</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>if</code></strong> ParenListExpression Substatement<sup>noShortIf</sup><strong><code>else</code></strong> Substatement<sup>full</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>IfStatement<sup>noShortIf</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>if</code></strong> ParenListExpression Substatement<sup>noShortIf</sup><strong><code>else</code></strong> Substatement<sup>noShortIf</sup></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131271"></a>Verification</h4>
<p>IfStatement : if ParenListExpression Substatement</p>
<p>IfStatement : if ParenListExpression Substatement else Substatement</p>
<ul>
<li>Verify the non-terminal symbols other right-hand side of the production</li>
</ul>
<h4>
<a name="wp131278"></a>Evaluation</h4>
<p>IfStatement : if ParenListExpression Substatement</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Let ref be the result of evaluating ParenListExpression</li>
  <li>Let obj be the result of readReference(ref)</li>
  <li>If toBoolean(obj) has the value true</li>
  <li>Return the result of evaluating Substatement</li>
  <li>Return cv</li>
</ul>
<p>IfStatement : if ParenListExpression Substatement1 else Substatement2</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Let ref be the result of evaluating ParenListExpression</li>
  <li>Let obj be the result of readReference(ref)</li>
  <li>If toBoolean(obj) has the value true</li>
  <li>Return the result of evaluating Substatement1 passing the argument cv</li>
  <li>Return the result of evaluating Substatement2 passing the argument cv</li>
</ul>
<h1>15.6.2 Switch statement</h1>
<h4>
<a name="wp146911"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>SwitchStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>switch</code></strong> ParenListExpression { CaseElements }</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>CaseElements</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>CaseLabel</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>CaseLabel CaseElementsPrefix CaseElement<sup>abbrev</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>CaseElementsPrefix</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>CaseElementsPrefix CaseElement<sup>full</sup></p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>CaseElement<sup>ω</sup></p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Directive<sup>ω</sup></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>CaseLabel</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>CaseLabel</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>case</code></strong> ListExpression<sup>allowIn</sup><strong><code>:</code></strong></p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p><strong><code>default :</code></strong></p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131383"></a>Semantics</h4>
<p>Switch statements have the same syntax and semantics as defined in ECMA-262 edition 3.</p>



  <h1>15.7 Iteration statements</h1>



  <h1>15.7.1 Do-while statement</h1>
<h4>
<a name="wp146917"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>DoStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>do Substatementabbrev while ParenListExpression</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131405"></a>Verification</h4>
<p>DoStatement : do Substatement while ParenListExpression</p>
<ul>
<li>Let continueTargets be the current set of possible targets of continue targets</li>
  <li>Let breakTargets be the current set of possible targets of break targets</li>
  <li>Add the label default to continueTargets by calling continueTargets.push(default)</li>
  <li>Add the label default to breakTargets by calling breakTargets.push(default)</li>
  <li>Verify Substatement</li>
  <li>Verify ParenListExpression</li>
</ul>
<h4>
<a name="wp131416"></a>Evaluation</h4>
<p>DoStatement : do Substatement while ParenListExpression</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Try</li>
  <li>Loop</li>
  <li>Try</li>
  <li>Let cv be the result of evaluating Substatement with argument cv</li>
  <li>Catch if exception x is of type Continue</li>
  <li>If x.label is a member of the current loop's continueTargets, then cv = x.value</li>
  <li>Throw x</li>
  <li>Let ref be the result of evaluating ParenListExpression</li>
  <li>Let obj be the result of readReference(ref)</li>
  <li>If toBoolean(obj) is not true, then return cv</li>
  <li>Catch if exception x is of type Break</li>
  <li>If x.label equals default then return x.value</li>
  <li>Throw x</li>
</ul>
<h1>15.17.2 While statement</h1>
<h4>
<a name="wp146922"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>WhileStatementw</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>While ParenListExpression Substatementw</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131451"></a>Verification</h4>
<p>WhileStatement : while ParenLIstExpression Substatement</p>
<ul>
<li>Let continueTargets be the current set of possible targets of continue targets</li>
  <li>Let breakTargets be the current set of possible targets of break targets</li>
  <li>Add the label default to continueTargets by calling continueTargets.push(default)</li>
  <li>Add the label default to breakTargets by calling breakTargets.push(default)</li>
  <li>Verify ParenListExpression</li>
  <li>Verify Substatement</li>
</ul>
<h4>
<a name="wp131462"></a>Evaluation</h4>
<p>DoStatement : do Substatement while ParenListExpression</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Try</li>
  <li>Loop</li>
  <li>Let ref be the result of evaluating ParenListExpression</li>
  <li>Let obj be the result of readReference(ref)</li>
  <li>If toBoolean(obj) is not true, then return cv</li>
  <li>Try</li>
  <li>Let cv be the result of evaluating Substatement with argument cv</li>
  <li>Catch if exception x is of type Continue</li>
  <li>If x.label is a member of the current loop's continueTargets, then cv = x.value</li>
  <li>Throw x</li>
  <li>Catch if exception x is of type Break</li>
  <li>If x.label equals default then return x.value</li>
  <li>Throw x</li>
</ul>
<h1>15.7.3 For statements</h1>
<h4>
<a name="wp146927"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ForStatementw</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>For ( ForInitializer ; OptionalExpression ; OptionalExpression ) Substatementw</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>For ( ForInBinding in ListExpressionallowIn ) Substatementw</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>For [no line break] each ( ForInBinding in ListExpressionallowIn ) Substatementw</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ForInitializer</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ListExpressionnoIn</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>VariableDefinitionnoIn</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ForInBinding</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>PostfixExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>VariableDefinitionKind VariableBindingnoIn</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>OptionalExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ListExpressionallowIn</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131565"></a>Semantics</h4>
<p>For statements in edition 4 have the same syntax and semantics as defined in ECMA-262 edition 3 and E4X.</p>



  <h1>15.8 Continue statement</h1>
<h4>
<a name="wp146933"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ContinueStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Continue</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>continue [no line break] Identifier</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131589"></a>Verification</h4>
<p>ContinueStatement : continue</p>
<ul>
<li>Let continueTargets be the current set of possible continue targets</li>
  <li>If default is not a member of continueTargets, throw a SyntaxError</li>
</ul>
<p>ContinueStatement : continue Identifier</p>
<ul>
<li>Let continueTargets be the current set of possible continue targets</li>
  <li>Let label be the sequence of characters of Identifier</li>
  <li>If label is not a member of continueTargets, throw a SyntaxError</li>
</ul>
<h4>
<a name="wp131602"></a>Evaluation</h4>
<p>ContinueStatement : continue</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Throw the exception Continue(cv,default)</li>
</ul>
<p>ContinueStatement : continue Identifier</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Let label be the sequence of characters of Identifier</li>
  <li>Throw the exception Continue(cv,label)</li>
</ul>
<h4>
<a name="wp131615"></a>Compatibility</h4>
<p>ActionScript 2.0 does not allow the second form of <i>ContinueStatement</i>. This is a compatible change. </p>



  <h1>15.9 Break statement</h1>
<h4>
<a name="wp146940"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>BreakStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>break</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>break [no line break] Identifier</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131640"></a>Verification</h4>
<p>BreakStatement : break</p>
<ul>
<li>Let breakTargets be the current set of possible break targets</li>
  <li>If default is not a member of breakTargets, throw a SyntaxError</li>
</ul>
<p>BreakStatement: break Identifier</p>
<ul>
<li>Let breakTargets be the current set of possible continue targets</li>
  <li>Let label be the sequence of characters of Identifier</li>
  <li>If label is not a member of breakTargets, throw a SyntaxError</li>
</ul>
<h4>
<a name="wp131653"></a>Evaluation</h4>
<p>BreakStatement: break</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Throw the exception Break(cv,default)</li>
</ul>
<p>BreakStatement: break Identifier</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Let label be the sequence of characters of Identifier</li>
  <li>Throw the exception Break(cv,label)</li>
</ul>
<h4>
<a name="wp131666"></a>Compatibility</h4>
<p>ActionScript 2.0 does not allow the second form of <i>BreakStatement</i>. This is a compatible change. </p>



  <h1>15.10 With statement</h1>
<h4>
<a name="wp146948"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>WithStatementw</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>with ParenListExpression Substatementw</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131687"></a>Semantics</h4>
<p>With statements have the same syntax and semantics as defined in ECMA-262 edition 3.</p>



  <h1>15.11 Return statement</h1>
<h4>
<a name="wp146954"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ReturnStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Return</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>return [no line break] ListExpressionallowIn</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131711"></a>Verification</h4>
<p>ReturnStatement : return</p>
<ul>
<li>Let env be the lexical environment</li>
  <li>If env does not contain a parameter frame</li>
  <li>Throw a SyntaxError exception</li>
</ul>
<p>ReturnStatement : return ListExpression</p>
<ul>
<li>Let env be the lexical environment</li>
  <li>If env does not contain a parameter frame</li>
  <li>Throw a SyntaxError exception</li>
  <li>Let frame be the enclosing parameter frame</li>
  <li>If frame does not allow a return value</li>
  <li>Throw a SyntaxError exception</li>
  <li>Verify ListExpression</li>
</ul>
<h4>
<a name="wp131729"></a>Evaluation</h4>
<p>BreakStatement: return</p>
<ul>
<li>Throw the exception Return(undefined)</li>
</ul>
<p>BreakStatement: return ListExpression</p>
<ul>
<li>Let ref be the result of evaluating ListExpression</li>
  <li>Let obj be the result of readReference(ref)</li>
  <li>Throw the exception Return(obj)</li>
</ul>
<h1>15.12 Throw statement</h1>
<h4>
<a name="wp146962"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ThrowStatement </p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>throw [no line break] ListExpressionallowIn</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131757"></a>Verification</h4>
<p>ThrowStatement : throw ListExpression</p>
<ul>
<li>Verify ListExpression</li>
</ul>
<h4>
<a name="wp131763"></a>Evaluation</h4>
<p>ThrowStatement : throw ListExpression</p>
<ul>
<li>Let ref be the result of evaluating ListExpression</li>
  <li>Let obj be the result of readReference(ref)</li>
  <li>Throw the value obj</li>
</ul>
<h1>15.13 Try statement</h1>
<h4>
<a name="wp146967"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>TryStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>try Block CatchClauses</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>try Block CatchClausesOpt finally Block</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>CatchClausesOpt</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>CatchClauses</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>CatchClauses</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>CatchClause</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>CatchClauses CatchClause</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>CatchClause</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>catch ( Parameter ) Block</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp131836"></a>Verification</h4>
<p>TryStatement : try Block CatchClauses</p>
<p>TryStatement : try Block1 CatchClausesOpt finally Block2</p>
<p>CatchClausesOpt : CatchClauses</p>
<p>CatchClauses : CatchClause</p>
<p>CatchClauses : CatchClauses CatchClause</p>
<ul>
<li>Verify each of the non-terminal symbols on the right-hand side of the production</li>
</ul>
<p>CatchClause : catch ( Parameter ) Block</p>
<ul>
<li>Let frame be an empty activation frame</li>
  <li>Let env be a copy of the current environment with frame added</li>
  <li>Verify Parameter with the arguments env and frame</li>
  <li>Verify Block with the argument env</li>
</ul>
<h4>
<a name="wp131853"></a>Evaluation</h4>
<p>TryStatement : try Block CatchClauses</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Try</li>
  <li>Let cv be the result of evaluating Block with argument cv</li>
  <li>Catch if exception x is of type Object  (note: excludes Return, Break and Continue exceptions)</li>
  <li>Let val be the result evaluating CatchClauses</li>
  <li>If val is not none, then return val</li>
  <li>Throw x</li>
</ul>
<p>TryStatement : try Block1 CatchClausesOpt finally Block2</p>
<ul>
<li>Let cv be a named argument passed to this evaluator</li>
  <li>Try</li>
  <li>Let cv be the result of evaluating Block1 with argument cv</li>
  <li>Catch if exception x is of type Object  (note: excludes Return, Break and Continue exceptions)</li>
  <li>Try</li>
  <li>Let val be the result evaluating CatchClauses</li>
  <li>If val is not none, then let e be have the value of x</li>
  <li>Else let e be none</li>
  <li>Catch if exception x</li>
  <li>Let e have the value of x</li>
  <li>Evaluate Block2</li>
  <li>If e is not equal to none, then throw e, else return val</li>
</ul>
<p>CatchClausesOpt : empty</p>
<ul>
<li>Return none</li>
</ul>
<p>CatchClausesOpt : CatchClauses</p>
<ul>
<li>Return the result of evaluating CatchClauses</li>
</ul>
<p>CatchClauses : CatchClause</p>
<ul>
<li>Return the result of evaluating CatchClause</li>
</ul>
<p>CatchClauses : CatchClauses CatchClause</p>
<ul>
<li>Let val be the result of evaluating CatchClauses</li>
  <li>If val is not equal to none, then return val</li>
  <li>Return the result of evaluating CatchClause</li>
</ul>
<p>CatchClause : catch ( Parameter ) Block</p>
<ul>
<li>Let env be a copy of the current lexical environment</li>
  <li>Let x be the named argument of this evaluator</li>
  <li>Let T be the type of Parameter</li>
  <li>Let name be the name of Parameter</li>
  <li>If x is of type T</li>
  <li>Let scope be instance of the activation frame of CatchClause</li>
  <li>Add scope to the lexical environment env</li>
  <li>Call writeProperty(scope,name,x)</li>
  <li>Return the result of evaluating Block</li>
  <li>Return none</li>
</ul>
<h1>15.14 Default XML namespace statement</h1>
<h4>
<a name="wp160660"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>DefaultXMLNamespaceStatement</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>default [no line break] xml [no line break] namespace = NonAssignmentExpressionb</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp160671"></a>Semantics</h4>
<p>DefaultXMLNamespaceStatement sets the internal DefaultXMLNamespace property to the value of NonAssignmentExpression. If a DefaultXMLNamespaceStatement appears in a function definition, the default xml namespace associated with the corresponding function object is initially set to the unnamed namespace.</p>



  <h1>16 Directives</h1>
<h4>
<a name="wp146972"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Directivew</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>EmptyStatement</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Statementw</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>AnnotatableDirectivew</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Attributes [no line break] AnnotatableDirectivew</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>IncludeDirective Semicolonw</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ImportDirective Semicolonw</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>UseDirective Semicolonw</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>AnnotatableDirectivew</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>VariableDefinitionallowIn Semicolonw</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>FunctionDefinition</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ClassDefinition</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>InterfaceDefinition</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>NamespaceDefinition Semicolonw</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Directives</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>DirectivesPrefix Directiveabbrev</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>DirectivesPrefix</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>DirectivesPrefix Directivefull</p>
    </td>
  </tr>
</table>
<h1>16.1 Attributes</h1>
<h4>
<a name="wp146977"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Attributes</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Attribute</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>AttributeCombination</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>AttributeCombination</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Attribute [no line break] Attributes</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Attribute</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>AttributeExpression</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ReservedNamespace</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>[ AssignmentExpressionallowIn ]</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>AttributeExpression</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>AttributeExpression PropertyOperator</p>
    </td>
  </tr>
</table>
<p>An <i>AttributeExpression</i> may be used as an <i>Attribute</i>.</p>
<p>An <i>Attribute</i> of one kind or another may be used before any <i>AnnotatableDirective</i>. <i>AnnotatableDirectives</i> include variable, function, class, interface, and namespace definitions.</p>
<p>Here is a complete list of reserved attribute names:</p>
<div class="listing">
<pre>
public
private
internal
protected
override
final
dynamic
native
static
</pre>
</div>
<h4>
<a name="wp132101"></a>Semantics</h4>
<p>The meaning of an <i>Attribute</i> depends on its compile-time value and its usage. See the description of the definitions being modified by the attribute.</p>



  <h1>16.2 Import directive</h1>
<h4>
<a name="wp146982"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ImportDirective</p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p>import PackageName . *</p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p>import PackageName . Identifier</p>    </td>
  </tr>
</table>
<p><i>ImportDirective</i> may be used where ever a Directive or <i>AnnotatableDirective</i> can be used.</p>
<div class="listing">
<pre>
import a.b.*
import a.b.x
</pre>
</div>
<h4>
<a name="wp132136"></a>Semantics</h4>
<p>An ImportDirective causes the simple and fully qualified names of one or more public definitions of the specified package to be introduced into the current package. Simple names will be shadowed by identical locally defined names. Ambiguous references to imported names result in runtime errors.</p>
<p>The wildcard form (import a.b.*) imports all public names in a package. The single name form (import a.b.x) imports only the specified name. </p>
<p>The mechanism for locating and loading imported packages is implementation defined.</p>
<h4>
<a name="wp132144"></a>Compatibility</h4>
<p>The ActionScript 2.0 behavior of raising an error if there are two classes with the same simple name being imported is deprecated. ActionScript 3.0 will import both classes, but references to the shared simple class name will result a compile-time error. Such references must be disambiguated by using a fully qualified class name.</p>
<p>The ActionScript 2.0 behavior of implicit import is also deprecated and will result in a compile-time error in ActionScript 3.0. To work around such errors, an explicit import directive must be added to the current package, which imports the referenced class.</p>



  <h1>16.3 Include directive</h1>
<h4>
<a name="wp146987"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>IncludeDirective</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>include [no line break] String</p>
    </td>
  </tr>
</table>
<p>An <i>IncludeDirective</i> may be used where ever a <i>Directive</i> may be used.</p>
<div class="listing">
<pre>
include "reusable.as"
</pre>
</div>
<h4>
<a name="wp132171"></a>Semantics</h4>
<p>An IncludeDirective results at compile time in the replacement of the text of the IncludeDirective with the content of the stream specified by String.</p>
<h4>
<a name="wp132176"></a>Compatibility</h4>
<p>In ActionScript 2.0, the include keyword is spelled <code>#include</code>. This form is deprecated and results in a compile warning in ActionScript 3.0.</p>



  <h1>16.4 Use directive</h1>
<h4>
<a name="wp146991"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>UseDirective</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>use namespace ListExpressionallowIn</p>
    </td>
  </tr>
</table>
<p>A <i>UseDirective</i> may be used where ever a <i>Directive</i> or <i>AnnotatableDirective</i> may be used. This includes the top-level of a <i>Program</i>, <i>PackageDefinition</i> and ClassDefinition.</p>
<div class="listing">
<pre>
use namespace ns1, ns2
</pre>
</div>
<h4>
<a name="wp132201"></a>Semantics</h4>
<p>A <i>UseDirective</i> causes the specified namespaces to be added to the open namespaces and removed when the current block scope is exited. Each sub expression of ListExpression must have a compile-time constant Namespace value.</p>
<h4>
<a name="wp132205"></a>Compatibility</h4>
<p>UseDirective is an extension to ActionScript 2.0.</p>



  <h1>17 Definitions</h1>



  <h1>17.1 Variable definition</h1>
<h4>
<a name="wp147001"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>VariableDefinitionb</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>VariableDefinitionKind VariableBindingListb</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>VariableDefinitionKind</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>var</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>const</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>VariableBindingListb</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>VariableBindingb</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>VariableBindingListb , VariableBindingb</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>VariableBindingb</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>TypedIdentifierb VariableInitialisationb</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>VariableInitialisationb</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>= VariableInitialiserb</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>VariableInitialiserb</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>AssignmentExpressionb</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>AttributeCombination</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>TypedIdentifierb</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier : TypeExpressionb</p>
    </td>
  </tr>
</table>
<p><i>TypedIdentifier</i> may be used in a <i>VariableBinding</i> or <i>Parameter</i> definition. </p>
<div class="listing">
<pre>
var x : String = "initial String value of var x"
function plusOne( n : Number ) { return n + 1 }
</pre>
</div>
<h4>
<a name="wp132348"></a>Semantics</h4>
<p><i>TypedIdentifer</i> results at compile-time in a variable or parameter that is optionally typed. The <i>TypeExpression</i>, if given, results at compile-time to a Type value. It is used to specify the set of values that are compatible with the variable or parameter being declared.</p>
<p>A VariableDefinition may be modified by the following attributes</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <code>static</code>
    </td>
    <td>
      <p>adds property to the class object</p>
    </td>
  </tr>
<tr>
<td>
      <code>prototype</code>
    </td>
    <td>
      <p>adds property to the prototype object</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <code>private</code>
    </td>
    <td>
      <p>accessible from within the current class</p>
    </td>
  </tr>
<tr>
<td>
      <code>public</code>
    </td>
    <td>
      <p>accessible outside the current package</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <code>protected</code>
    </td>
    <td>
      <p>accessible from within an instance of the current class or a derived classes</p>
    </td>
  </tr>
<tr>
<td>
      <code>internal</code>
    </td>
    <td>
      <p>accessible from within the current package</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp132361"></a>Compatibility</h4>
<p>Typed identifier behavior differs between ActionScript 3.0 and ActionScript 2.0 in two ways. ActionScript 2.0 checks for type compatibility using compile-time types at compile time, while ActionScript 3.0 checks for type compatibility using runtime types at runtime. The difference can be seen in the following examples:</p>
<div class="listing">
<pre>
var s : String = o
function f( s : String ) {}
var o = 10
f(o)    // OK in ActionScript 2.0, error in ActionScript 3.0
</pre>
</div>
<p>In ActionScript 2.0, the variable <code>o</code> does not have an explicit compile-time type that can be compared to the type String of the parameter <code>s</code> in the call to function <code>f</code>, so no error is reported. In ActionScript 3.0, the value of argument <code>o</code> is compared to the type of the parameter <code>s</code> at runtime, resulting in an error.</p>
<div class="listing">
<pre>
class A {}
class B extends A { var x }
var a : A = new B
a.x = 20   // Error in ActionScript 2.0, OK in ActionScript 3.0 (since instance of B has an x property)
</pre>
</div>
<p>In ActionScript 2.0, the compiler uses A, the declared type of <code>a</code>, to conservatively check for valid uses of <code>a</code>, excluding completely safe and reasonable uses of <code>a</code>. In ActionScript 3.0, the compiler uses the type of <code>a</code> to optimize its use, but does not report type errors. It leaves that task to the runtime.</p>



  <h1>17.2 Function definition</h1>
<h4>
<a name="wp147006"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FunctionDefinition</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>function FunctionName FunctionCommon</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp155246"></a>Semantics</h4>
<p>A FunctionDefinition introduces a new name and binds that name to a newly created function object specified by FunctionCommon. The implementation of the function object depends on whether the function is static or virtual as indicated by its context and attributes.</p>
<p>A FunctionDefinition may be modified by the following attributes</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <code>static</code>
    </td>
    <td>
      <p>Adds property to the class object</p>
    </td>
  </tr>
<tr>
<td>
      <code>prototype</code>
    </td>
    <td>
      <p>Adds property to the prototype object</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <code>final</code>
    </td>
    <td>
      <p>Adds non-overridable property to each instance </p>
    </td>
  </tr>
<tr>
<td>
      <code>override</code>
    </td>
    <td>
      <p>Overrides a method of the base class</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <code>private</code>
    </td>
    <td>
      <p>Accessible from within the current class</p>
    </td>
  </tr>
<tr>
<td>
      <code>public</code>
    </td>
    <td>
      <p>Accessible outside the current package</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <code>protected</code>
    </td>
    <td>
      <p>Accessible from within an instance of the current or a derived classes</p>
    </td>
  </tr>
<tr>
<td>
      <code>internal</code>
    </td>
    <td>
      <p>Accessible from within the current package</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <code>native</code>
    </td>
    <td>
      <p>Generates a native stub (implementation defined)</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp156015"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FunctionName</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>get [no line break] Identifier</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>set [no line break] Identifier</p>
    </td>
  </tr>
</table>
<p><i>FunctionName</i> is used inside a <i>FunctionDefinition</i>.</p>
<div class="listing">
<pre>
function f() {}
function get x () { return impl.x }
function set x (x) { impl.x = x }
</pre>
</div>
<h4>
<a name="wp132442"></a>Semantics</h4>
<p><i>FunctionName</i> specifies at compile time the name and kind of function being defined. A name that includes a <code>get</code> or <code>set</code> modifier specifies that the function being defined is a property accessor.</p>



  <h1>17.2.1 Function body</h1>
<h4>
<a name="wp147016"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FunctionCommon</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>FunctionSignature</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>FunctionSignature Block</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp132466"></a>Verification</h4>
<p>A FunctionCommon that is a FunctionSignature without a Block introduces an abstract method trait. A FunctionCommon with a FunctionSignature followed by a Block defines a concrete function. The result of verifying a FunctionCommon node is the addition of a method trait to a set of traits associated with an object at runtime. </p>
<h4>
<a name="wp132470"></a>Evaluation</h4>
<p>During evaluation, a FunctionCommon node is instantiated and activated. Function instantiation is when a lexical environment is associated with a function object. This captured environment is used to activate the function. Activation is when the function is called with a specific receiver (<code>this</code>) and set of arguments.</p>



  <h1>17.2.2 Function signature</h1>
<h4>
<a name="wp147021"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>FunctionSignature</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>( ) ResultType</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>( Parameters ) ResultType</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp132494"></a>Semantics</h4>
<p>The function signature defines the set of traits associated with the activation of a function object.</p>



  <h1>17.2.3 Parameter list</h1>
<p>In the strict dialect, the Arguments assigned to Parameters must have compatible number and types. In the standard dialect, the handling of arguments is the same as edition 3.</p>
<h4>
<a name="wp147025"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Parameters</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>NonemptyParameters</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>NonemptyParameters</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Parameter</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Parameter , NonemptyParameters</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>RestParameter</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Parameter</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>TypedIdentifierallowIn</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>TypedIdentifierallowIn = AssignmentExpressionallowIn</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>RestParameter</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>...</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>... Identifier</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp132573"></a>Verification</h4>
<p>Parameters : empty</p>
<ul>
<li>Do nothing</li>
</ul>
<p>Parameters : NonemptyParameters</p>
<ul>
<li>Verify NonemptyParameters</li>
</ul>
<p>NonemptyParameters : Parameter</p>
<ul>
<li>Let frame be the named argument passed into this verifier</li>
  <li>Verify Parameter</li>
  <li>Let name be the name of Parameter</li>
  <li>Let type be the type of Parameter</li>
  <li>Call defineSlotTrait(frame,name,type,false)</li>
</ul>
<p>NonemptyParameters : Parameter , NonemptyParameters</p>
<ul>
<li>Let frame be the named argument passed into this verifier</li>
  <li>Verify Parameter</li>
  <li>Verify NonemptyParameters with the argument frame</li>
  <li>Let name be the name of Parameter</li>
  <li>Let type be the type of Parameter</li>
  <li>Call defineSlotTrait(frame,name,type,false)</li>
</ul>
<p>NonemptyParameters : RestParameter</p>
<ul>
<li>Verify RestParameter</li>
</ul>
<p>Parameter : TypedIdentifier</p>
<ul>
<li>Verify TypedIdentifier</li>
  <li>Let name be the name of TypedIdentifier</li>
  <li>Let type be the type of TypedIdentifier</li>
  <li>Call defineSlotTrait(frame,name,type,undefined,false)</li>
</ul>
<p>Parameter : TypedIdentifier = AssignmentExpression</p>
<ul>
<li>Verify TypedIdentifier</li>
  <li>Verify AssignmentExpression</li>
  <li>Let name be the name of TypedIdentifier</li>
  <li>Let type be the type of TypedIdentifier</li>
  <li>Let val be the value of AssignmentExpression</li>
  <li>If val is equal to none, then throw a VerifyError: must be a compile-time constant</li>
  <li>Call defineSlotTrait(frame,name,type,val,false)</li>
</ul>
<p>RestParameter : …</p>
<ul>
<li>Do nothing</li>
</ul>
<p>RestParameter : … Identifier</p>
<ul>
<li>Let frame be a named argument passed into this verifier</li>
  <li>Verify Identifier</li>
  <li>Let name be the name of Identifier</li>
  <li>Call defineSlotTrait(frame,name,Array,false)</li>
</ul>
<h1>17.2.4 Result type</h1>
<h4>
<a name="wp147030"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ResultType</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>: TypeExpressionallowIn</p>
    </td>
  </tr>
</table>
<p><i>ResultType</i> may be used in a <i>FunctionSignature</i>. </p>
<div class="listing">
<pre>
function f(x) : Number { return x }
</pre>
</div>
<h4>
<a name="wp132657"></a>Semantics</h4>
<p><i>ResultType</i> guarantees the type of the value returned from a function. It is a verify error if the return value does not implicitly convert to the ResultType of the function.</p>
<h4>
<a name="wp132661"></a>Compatibility</h4>
<p>The ActionScript 2.0 behavior of checking types only at compile time is more permissive than in ActionScript 3.0. This will result in new runtime errors in cases such as calling the method shown above with an argument of type String.</p>



  <h1>17.3 Class definition</h1>
<h4>
<a name="wp147034"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ClassDefinition</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Class ClassName Inheritance Block</p>
    </td>
  </tr>
</table>
<p><i>ClassDefinition</i> may be used where ever an <i>AnnotatableDirective</i> may be used, which includes wherever a Directive can be used and following a list of attributes, except inside of another ClassDefinition or InterfaceDefinition.</p>
<div class="listing">
<pre>
class A extends B implements C {}
dynamic public final class D {}
</pre>
</div>


  <h1>17.3.1 Class attributes</h1>
<p>Class definitions may be modified by the following attributes:</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>internal</p>
    </td>
    <td>
      <p>Visible to references inside the current package (default)</p>
    </td>
  </tr>
<tr>
<td>
      <p>public</p>
    </td>
    <td>
      <p>Visible to references everywhere</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>final</p>
    </td>
    <td>
      <p>Prohibit extension by sub-classing</p>
    </td>
  </tr>
<tr>
<td>
      <p>dynamic</p>
    </td>
    <td>
      <p>Allow the addition of dynamic properties</p>
    </td>
  </tr>
</table>
<p>The default attributes for a class definition are internal, non-dynamic, and non-final. </p>
<h4>
<a name="wp132713"></a>Semantics</h4>
<p>A class definition adds a new class name into the current scope. In the following drawing, the class name A refers to a class object with the structure shown in the drawing:</p>
<div class="listing">
<pre>
class A {}
</pre>
</div>
<p><br><img src="/web/20171028212944im_/http://bloople.net/as3ls/images/as3_specificationa5.jpg" border="0" hspace="0" vspace="0"><br></p>
<p>A class definition causes a class object and prototype instance to be created. The default delegate of the instance prototype is the Object prototype. The default super class of the class object is the Object class. Static members are added to the class object as fixed properties, and non-static members are added to the instance prototype as fixed properties. The internal references (traits, prototype, constructor, and delegate) between these objects are read-only.</p>



  <h1>17.3.2 Class name</h1>
<h4>
<a name="wp147039"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ClassName</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>ClassIdentifiers</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ClassIdentifiers</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>ClassIdentifiers . Identifier</p>
    </td>
  </tr>
</table>
<p><i>ClassName</i> can be used in <i>ClassDefinition</i>.</p>
<div class="listing">
<pre>
class A {}
</pre>
</div>
<h4>
<a name="wp132781"></a>Semantics</h4>
<p><i>ClassName</i> evaluates at compile time to a type name.</p>
<h4>
<a name="wp132785"></a>Compatibility</h4>
<p>The form <i>ClassIdentifiers : ClassIdentifiers</i> . <i>Identifier</i> is deprecated. It is equivalent to declaring the class name I<i>dentifier</i> in the package <i>ClassIdentifiers</i>.</p>
<div class="listing">
<pre>
class P.A {}        // deprecated
package P {        // preferred
    class A {}
}
</pre>
</div>


  <h1>17.3.3 Class inheritance</h1>
<h4>
<a name="wp147044"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Inheritance</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>extends TypeExpressionallowIn</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>implements TypeExpressionList</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>extends TypeExpressionallowIn implements TypeExpressionList</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>TypeExpressionList</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>TypeExpressionallowIn</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>TypeExpressionList , TypeExpressionallowIn</p>
    </td>
  </tr>
</table>
<h4>
<a name="wp132839"></a>Semantics</h4>
<p>A <i>ClassDefinition</i> may extend another class definition and implement one or more interfaces. We say that a class inherits the properties of its base class and the abstract methods of its interfaces. When a class extends another class, it is inherits the base class's instance properties, but not its static properties. When a class implements one or more interfaces it is required to define each inherited interface method.</p>
<p>The <i>TypeExpressions</i> that occur in the <code>extends</code> and <code>implements</code> clauses must be compile-time constant expressions without forward references.</p>



  <h1>17.3.4 Class block</h1>
<h4>
<a name="wp147048"></a>Syntax</h4>
<p>The body of a class definition is syntactically a Block. The class block must come immediately after the ClassName or Inheritance constituents, if present. The class block must not contain a ClassDefinition or InterfaceDefinition.</p>
<h4>
<a name="wp132851"></a>Semantics</h4>
<p>Declarations modified by the <code>static</code> attribute contribute properties to the class object; declarations without the <code>static</code> attribute contribute properties to the instance traits object. Statements that are not declarations are evaluated normally when the class object is instantiated.</p>
<h4>
<a name="wp132854"></a>17.3.4.1 Variables</h4>
<p>The following attributes are allowed in variable definitions in a class block:</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>static</p>
    </td>
    <td>
      <p>Defines a property of the class object</p>
    </td>
  </tr>
<tr>
<td>
      <p>private</p>
    </td>
    <td>
      <p>Visible to references inside the current class</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>internal</p>
    </td>
    <td>
      <p>Visible to references inside the current package</p>
    </td>
  </tr>
<tr>
<td>
      <p>protected</p>
    </td>
    <td>
      <p>Visible to references inside an instance of the current class and derived classes</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>prototype</p>
    </td>
    <td>
      <p>Defines a property of the class prototype object</p>
    </td>
  </tr>
<tr>
<td>
      <p>public</p>
    </td>
    <td>
      <p>Visible to references everywhere</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>AttributeExpression</p>
    </td>
    <td>
      <p>Namespace value is the qualifier for the name of the definition</p>
    </td>
  </tr>
</table>
<p>The default attributes for variable definitions are non-static and internal.</p>
<h4>
<a name="wp132891"></a>17.3.4.2 Methods</h4>
<p>The following attributes are allowed in function definitions in a class block:</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>static</p>
    </td>
    <td>
      <p>Defines a property of the class object</p>
    </td>
  </tr>
<tr>
<td>
      <p>final</p>
    </td>
    <td>
      <p>Must not be overridden</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>override</p>
    </td>
    <td>
      <p>Must redefine an inherited non-final method</p>
    </td>
  </tr>
<tr>
<td>
      <p>native</p>
    </td>
    <td>
      <p>Implementation defined</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>private</p>
    </td>
    <td>
      <p>Visible to references inside the current class</p>
    </td>
  </tr>
<tr>
<td>
      <p>internal</p>
    </td>
    <td>
      <p>Visible to references inside the current package</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>protected</p>
    </td>
    <td>
      <p>Visible to references inside instances of the current class and derived classes</p>
    </td>
  </tr>
<tr>
<td>
      <p>public</p>
    </td>
    <td>
      <p>Visible to references everywhere</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p>AttributeExpression</p>
    </td>
    <td>
      <p>Namespace value is the qualifier for the name of the definition</p>
    </td>
  </tr>
</table>
<p>The default attributes for function definitions in a class are non-static , non-final, non-native and internal.</p>
<p>Methods that implement interface methods must be instance methods defined with attributes that include <code>public</code>. Interface methods may be overridden in a derived class as long as the overriding method also has the <code>public</code> attribute. </p>
<p>A constructor method is a method with the same name as the class it is defined in. It is a syntax error for the constructor method to have a different namespace attribute than its class. </p>
<p>It is a verifier error for <code>override</code> to appear as an attribute of a class method that does not override another method.</p>



  <h1>17.4 Interface definition</h1>
<h4>
<a name="wp147053"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>InterfaceDefinition</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>interface ClassName ExtendsList Block</p>
    </td>
  </tr>
</table>
<p>An <i>InterfaceDefinition</i> may be used where ever a <i>Directive</i> or <i>AnnotatableDirective</i> may be used, which includes wherever a Directive can be used and following a list of attributes, except inside of another ClassDefinition or InterfaceDefinition.</p>
<div class="listing">
<pre>
interface T { function m() }
</pre>
</div>
<h4>
<a name="wp132963"></a>Semantics</h4>
<p>An <i>InterfaceDefinition</i> constrains the structure of any <i>ClassDefinition</i> that implements it. These constraints are enforced when the ClassDefinition is being compiled. An <i>InterfaceDefinition</i> also introduces a new type name into the current scope. When evaluated in a context that expects a type value, a reference to that name is equivalent to the set of types comprising the types of all instances of all classes that implement the interface.</p>
<h4>
<a name="wp132967"></a>Compatibility</h4>
<p>In ActionScript 2.0, user-defined types only exist at compile time. Therefore, any use of an interface name that cannot be enforced at compile time will have no effect on the program. See descriptions of ResultType and TypeIdentifier.</p>



  <h1>17.4.1 Interface attributes</h1>
<p>Interface definitions may be modified by these attributes</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td>
      <p>internal</p>
    </td>
    <td>
      <p>Visible to references inside the current package (default)</p>
    </td>
  </tr>
<tr>
<td>
      <p>public</p>
    </td>
    <td>
      <p>Visible to references everywhere</p>
    </td>
  </tr>
</table>
<p>The default modifier for an interface definition is internal.</p>



  <h1>17.4.2 Interface name</h1>
<p>The name of an interface definition has the syntax and semantics of a ClassName (section 16.3.1).</p>



  <h1>17.4.3 Interface inheritance</h1>
<h4>
<a name="wp147059"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>ExtendsList</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>extends TypeExpressionList</p>
    </td>
  </tr>
</table>
<p>An ExtendsList may be used after the ClassName and before Block in an InterfaceDefinition.</p>
<div class="listing">
<pre>
interface U extends T { function n() }
</pre>
</div>
<h4>
<a name="wp133018"></a>Semantics</h4>
<p>An ExtendsList specifies the interfaces that include instances of the current InterfaceDefinition in their value set. It also specifies that the current InterfaceDefinition inherits the structure of each of the interfaces named in the ExtendsList.</p>
<p>An interface definition must not introduce a method with a name that has the same identifier as an inherited method.</p>
<p>An interface definition must not inherit itself directly or indirectly.</p>



  <h1>17.4.4 Interface block</h1>
<p>The body of an interface definition is syntactically a Block, but must only contain FunctionDefinitions with no Block and no attribute.</p>
<h4>
<a name="wp133029"></a>17.4.4.1 Interface methods</h4>
<p>Interface methods must be defined with no attribute. An interface method is given the name that has its interface as its qualifier and the identifier as the string. </p>
<p>Interface methods have the syntax of a FunctionDefinition without the Block of FunctionCommon. Class methods that implement interface methods must match the name and signature, including parameter count, types and result type, exactly. The name of the implementing method must have a name that is qualified by the public namespace.</p>



  <h1>17.5 Package definition</h1>
<h4>
<a name="wp147065"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>PackageDefinition</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>package PackageNameOpt Block</p>
    </td>
  </tr>
</table>
<p>A <i>PackageDefinition</i> may be used in a <i>Program</i> before any <i>Directive</i> that is not a <i>PackageDefinition</i> is used.</p>
<div class="listing">
<pre>
package p { 
    public class A {}
    public interface I {}
}
package q { 
    public var x = 10
}
import p.*
import q.f
import y = q.x

class B extends A implements I {}
q.f()
trace(x)
</pre>
</div>
<h4>
<a name="wp133068"></a>Semantics</h4>
<p>A <i>PackageDefinition</i> introduces a new package name into the current scope. A package definition causes the public members of that package to be qualified by the package name, and the internal members of that package definition to be qualified by an anonymous namespace that is only accessible to code inside the package. </p>
<p>The statements of a package body are executed in the global scope of the Program.</p>
<h4>
<a name="wp133074"></a>Compatibility</h4>
<p>PackageDefinition is an extension to ActionScript 2.0. It is added to ActionScript 3.0 to replace the deprecated form of ClassDefinition that uses a ClassName qualified by a package name.</p>



  <h1>17.5.1 Package name</h1>
<h4>
<a name="wp147070"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>PackageName</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>PackageName . Identifier</p>
    </td>
  </tr>
</table>
<h1>17.6 Namespace definition</h1>
<h4>
<a name="wp147074"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>NamespaceDefinition</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>namespace NamespaceBinding</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>NamespaceBinding</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Identifier NamespaceInitialisation</p>
    </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>NamespaceInitialisation</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>«empty»</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>= AssignmentExpressionallowIn</p>
    </td>
  </tr>
</table>
<p>A <i>NamespaceDefinition</i> may be used where ever a <i>Directive</i> or <i>AnnotatableDirective</i> may be used. This includes the top-level of a <i>Program</i>, <i>PackageDefinition</i> and ClassDefinition.</p>
<div class="listing">
<pre>
namespace NS1
namespace NS2 = NS1
namespace NS3 = "http://www.macromedia.com/flash/2005"
</pre>
</div>
<h4>
<a name="wp133149"></a>Semantics</h4>
<p>A <i>NamespaceDefinition</i> introduces a new namespace constant into the current block scope and assigns to it either an anonymous namespace value, or the value of the AssignmentExpression in the NamespaceInitialisation implicitly coerced to type Namespace.  The value of NamespaceInitialisation must be a compile-time constant with a value of type String or type Namespace.</p>
<p><i>NamespaceDefinitions</i> can be annotated by an access specifier (<code>private</code>,  <code>internal</code>, <code>protected</code> or <code>public</code>), the <code>static</code> modifier inside a <i>ClassDefinition</i>.</p>



  <h1>17.7 Program definition</h1>
<h4>
<a name="wp147079"></a>Syntax</h4>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Program</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Directives</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>PackageDefinition Program</p>
    </td>
  </tr>
</table>
<div class="listing">
<pre>
 package P { 
    function f() {} 
}
package Q { 
    function f() {} 
}
P.f()
Q.f()
</pre>
</div>


  <h1>18 Errors</h1>



  <h1>18.1 Class errors</h1>
<p>The following errors may occur while parsing or verifying a class definition:</p>
<ul>
<li>Defining a class with the name of another definition in the same scope</li>
  <li>Defining a class that extends itself directly or indirectly</li>
  <li>Defining a constructor with a namespace attribute that is different than the namespace attribute of its class</li>
  <li>Defining a constructor with a result type</li>
  <li>Defining a constructor that calls its super constructor more than once</li>
  <li>Defining a constructor that calls its super constructor accessing a non-local property</li>
  <li>Introducing a method or variable with the same name as an inherited method or variable</li>
  <li>Overriding a variable</li>
  <li>Overriding a final method</li>
  <li>Overriding a method that is not defined in a base class</li>
  <li>Overriding a method with a method that has a different number, types of parameters, or result type</li>
</ul>
<h1>18.2 Interface errors</h1>
<p>The following errors may occur while parsing or verifying an interface definition:</p>
<ul>
<li>Defining an interface with the name of another definition in the same scope</li>
  <li>Defining an interface that extends itself directly or indirectly</li>
  <li>Defining an interface with a body that contain a definition or statement other than a function definition with no block</li>
  <li>Defining an interface method with the same identifier as an inherited interface method</li>
  <li>Defining an interface method with an attribute</li>
</ul>
<h1>18.3 Package errors</h1>
<p>The following list describes package errors:</p>
<ul>
<li>It is a parser error to define a package inside a package.</li>
  <li>It is a parser error to use attributes on a package definition.</li>
  <li>It is a parser error to import a package's names into itself</li>
  <li>It is a strict error to import the same name more than once into the same package.</li>
  <li>It is a strict error to import a package that cannot be found.</li>
  <li>It is a strict error to reference a package property that cannot be found in an imported package.</li>
</ul>
<h1>18.4 Namespace errors</h1>
<p>The following list describes namespace errors:</p>
<ul>
<li>It is a verifier error to use an expression that does not have a compile-time constant namespace value in a use namespace directive.</li>
  <li>It is a verifier error to use an attribute expression that is not a compile-time constant namespace value as a definition attribute. </li>
  <li>It is a verifier error to use a user-defined namespace as an attribute except to define a class or instance property.</li>
</ul>
<h1>19 Native objects</h1>
<p>The form and function of the native objects is the same as ECMA-262 edition 3 except that all prototype properties are also implemented as class methods. Prototype properties that are functions are implemented as regular methods. Prototype properties that are variables are implemented as a pair of get and set methods that forward state to the prototype property.</p>



  <h1>19.1 Global object</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Global object</p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p>NaN</p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p>Infinity</p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p>undefined</p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p>parseInt</p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p>parseFloat</p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p>isNaN</p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p>isFinite</p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p>decodeURI</p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p>decodeURIComponent</p>    </td>
  </tr>
<tr>
<td>
      <p> </p>    </td>
    <td>
      <p>encodeURI</p>    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>    </td>
    <td>
      <p>encodeURIComponent</p>    </td>
  </tr>
</table>
<h1>19.2 Object objects</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Object object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Object</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Object.prototype</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Object.prototype.constructor</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Object.prototype.toString</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Object.prototype.toLocaleString</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Object.prototype.valueOf</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Object.prototype.hasOwnProperty</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Object.prototype.isPrototypeOf</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Object.prototype.propertyIsEnumerable</p>
    </td>
  </tr>
</table>
<h1>19.3 Function objects</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Function object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Function</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Function.prototype</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Function.prototype.constructor</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Function.prototype.toString</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Function.prototype.apply</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Function.prototype.call</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Function.length</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Function.prototype</p>
    </td>
  </tr>
</table>
<h1>19.4 Array objects</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Array object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.constructor</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.toString</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.toLocaleString</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.concat</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.join</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.pop</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.push</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.reverse</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.shift</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.slice</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.sort</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.splice</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.prototype.unshift</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.[[Put]]</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Array.length</p>
    </td>
  </tr>
</table>
<h1>19.5 String objects</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>String object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.fromCharCode</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.constructor</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.toString</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.valueOf</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.charAt</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.charCodeAt</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.concat</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.indexOf</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.lastIndexOf</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.localeCompare</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.match</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.replace</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.search</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.slice</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.split</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.substring</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.toLowerCase</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.prototype.toLocaleLowerCase</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.protoype.toUpperCase</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.protoype.toLocaleUpperCase</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>String.[[Value]]</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>String.length</p>
    </td>
  </tr>
</table>
<h1>19.6 Boolean objects</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Boolean object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Boolean</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Boolean.prototype</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Boolean.prototype.constructor</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Boolean.prototype.toString</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Boolean.prototype.valueOf</p>
    </td>
  </tr>
</table>
<h1>19.7 Number objects</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Number object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Number</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.prototype</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.MAX_VALUE</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.MIN_VALUE</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.NaN</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.NEGATIVE_INFINITY</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.POSITIVE_INFINITY</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.protoype.constructor</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.protoype.toString</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.prototype.toLocaleString</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.prototype.valueOf</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.prototype.toFixed</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.prototype.toExponential</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Number.prototype.toPrecision</p>
    </td>
  </tr>
</table>
<h1>19.8 Math object</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Math object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.E</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.LN10</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.LN2</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.LOG2E</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.LOG10E</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.PI</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.SQRT1_2</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.SQRT2</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.abs</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.acos</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.asin</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.atan</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.atan2</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.ceil</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.cos</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.exp</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.floor</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.log</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.max</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.min</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.pow</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.random</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.round</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.sin</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.sqrt</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Math.tan</p>
    </td>
  </tr>
</table>
<h1>19.9 Date objects</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Date object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.protoype</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.parse</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.UTC</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.constructor</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.toString</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.toDateString</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.toTimeString</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.toLocaleString</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.toLocaleDateString</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.toLocaletimeString</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.valueOf</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getTime</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getFullYear</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getUTCFullYear</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getMonth</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getUTCMonth</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getDate</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getUTCDate</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getDay</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getUTCDay</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getHours</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getUTCHours</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getMinutes</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getUTCMinutes</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getSeconds</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getUTCSeconds</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getMilliseconds</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getUTCMilliseconds</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.getTimezoneOffset</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setTime</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setMilliseconds</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setUTCMilliseconds</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setSeconds</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setUTCSeconds</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setMinutes</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setUTCMinutes</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setHours</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setUTCHours</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setDate</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setUTCDate</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setMonth</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setUTCMonth</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setFullYear</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.setUTCFullYear</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Date.prototype.toUTCString</p>
    </td>
  </tr>
</table>
<h1>19.10 Error objects</h1>
<table border="0" cellpadding="0" cellspacing="0">
<tr bgcolor="#F8F8F8">
<td colspan="2" rowspan="1">
      <p>Error object</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Error</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Error.prototype</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Error.prototype.constructor</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Error.prototype.name</p>
    </td>
  </tr>
<tr>
<td>
      <p> </p>
    </td>
    <td>
      <p>Error.prototype.message</p>
    </td>
  </tr>
<tr bgcolor="#F8F8F8">
<td>
      <p> </p>
    </td>
    <td>
      <p>Error.prototype.toString</p>
    </td>
  </tr>
</table>
<h1>20 Compatibility with the static profile</h1>
<p>The static profile defines a dialect that is a subset of ActionScript 3.0. It allows for the static interpretation of type names and the reporting of verifier errors ahead-of-time. </p>



  <h1>21 Compatibility with ECMAScript edition 3</h1>
<p>While we have made this edition as compatible as possible with the ECMAScript (ECMA-262) edition 3 language specification, there are certain behaviors for which there is no clear use case and keeping them as-is would have been placed an unneeded heavy burden on the new features of the language. In such cases, we have made small and calculated changes to allow the new definition to be simpler and easier to use. </p>



  <h1>21.1 this inside of nested function</h1>
<p>In ECMA-262 edition 3, when <code>this</code> appears in a nested function, it is bound to the global object if the function is called lexically, without an explicit receiver object. In ActionScript 3.0, <code>this</code> is bound to the innermost nested <code>this</code> when the function is called lexically.</p>



  <h1>21.2 No boxing of primitives</h1>
<p>In ECMA-262 edition 3, primitive values (Boolean, Number, String) are boxed in Object values in various contexts. In ActionScript 3.0, primitives are permanently sealed Objects. Unlike boxed objects, attempts to dynamically extend a sealed object results in a runtime exception.</p>



  <h1>21.3 Assignment to const is a runtime exception</h1>
<p>In ECMA-262 edition 3, primitive assignment to read-only properties failed silently. In ActionScript 3.0, primitive assignment to read-only properties causes a runtime error to be thrown. </p>



  <h1>21.4 Class names are const</h1>
<p>In ECMA-262 edition 3, constructor functions were writable. In ActionScript 3.0, we implement these properties with class definitions, which are read only. </p>



  <h1>21.5 Array arguments object</h1>
<p>In ECMA-262 edition 3, the function <code>arguments</code> property is a generic Object. In ActionScript 3.0, <code>arguments</code> is an Array. </p>



  <h1>22 Compatibility with E4X</h1>
<p>We have made ActionScript 3.0 as compatible as possible with the ECMAScript for XML (E4X) specification (ECMA-357 edition 2). ActionScript 3.0 diverges from the E4X specification in a small number of cases due to minor errors in the current edition of the E4X specification.</p>



  </body>
</html>